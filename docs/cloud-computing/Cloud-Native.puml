@startmindmap
title =<i><u>Cloud Native\n<img:images/img.png>

* <i><size:12><b>[[https://learn.microsoft.com/en-us/dotnet/architecture/cloud-native/definition What is Cloud Native?]] Microsoft Article
!theme hacker


*[#darkblue] <color #white><i>Definition
**[#lightblue] <i><size:12>A software development approach that emphasizes building applications specifically for cloud environments
**[#lightblue] <i><size:12>Cloud-native applications are designed to be scalable, resilient, and easily managed in dynamic and distributed environments

*[#darkblue] <color #white><i>Key Principles
**[#lightblue] <i><size:12>Microservices Architecture
***[#yellow] <i><size:12>Application is composed of small, independent services that can be developed, deployed, and scaled independently
***[#yellow] <i><size:12>Each service runs in its own process and communicates with other services using lightweight mechanisms
**[#lightblue] <i><size:12>Containerization
***[#yellow] <i><size:12>Applications are packaged as containers, which provide a lightweight and portable runtime environment
***[#yellow] <i><size:12>Containers can be easily deployed, scaled, and managed across different environments
**[#lightblue] <i><size:12>[[docs/3-devops/devops-plantuml-mindmap/advance-infrastructure-as-code.puml Infrastructure as Code]]
***[#yellow] <i><size:12>Infrastructure is defined and managed using code, which makes it easier to automate and manage at scale
***[#yellow] <i><size:12>Changes to infrastructure can be version-controlled and deployed using automated pipelines
**[#lightblue] <i><size:12>[[docs/3-devops/devops-plantuml-mindmap/DevOps.puml DevOps]]
***[#yellow] <i><size:12>Culture and practices that emphasize collaboration and automation between development and operations teams
***[#yellow] <i><size:12>DevOps enables teams to deliver software faster, with higher quality, and more reliably

*[#darkblue] <color #white><i>Benefits
**[#lightblue] <i><size:12>Scalability and Resilience
***[#yellow] <i><size:12>Cloud-native applications can handle large and unpredictable workloads by scaling up or down as needed
***[#yellow] <i><size:12>Applications are designed to be resilient to failures and can automatically recover from them
**[#lightblue] <i><size:12>Agility and Time-to-Market
***[#yellow] <i><size:12>Cloud-native development enables faster release cycles and allows teams to respond quickly to changing lightblue requirements
***[#yellow] <i><size:12>Teams can experiment and innovate more easily using cloud-native technologies and services
**[#lightblue] <i><size:12>Cost Efficiency
***[#yellow] <i><size:12>Cloud-native applications can be more cost-effective by leveraging cloud resources more efficiently
***[#yellow] <i><size:12>Containerization enables better resource utilization and reduces infrastructure overhead

*[#darkblue] <color #white><i>Cloud-Native Technologies
**[#lightblue] <i><size:12>Container Orchestration
***[#yellow] <i><size:12>Kubernetes
***[#yellow] <i><size:12>Docker Swarm
**[#lightblue] <i><size:12>Service Mesh
***[#yellow] <i><size:12>Istio
***[#yellow] <i><size:12>Linkerd
**[#lightblue] <i><size:12>Cloud-Native Databases
***[#yellow] <i><size:12>Amazon DynamoDB
***[#yellow] <i><size:12>Google Cloud Spanner
***[#yellow] <i><size:12>MongoDB Atlas
**[#lightblue] <i><size:12>Cloud-Native Storage
***[#yellow] <i><size:12>Amazon S3
***[#yellow] <i><size:12>Google Cloud Storage
***[#yellow] <i><size:12>Azure Blob Storage
**[#lightblue] <i><size:12>Serverless Computing
***[#yellow] <i><size:12>AWS Lambda
***[#yellow] <i><size:12>Google Cloud Functions
***[#yellow] <i><size:12>Azure Functions

*[#darkblue] <color #white><i>Challenges
**[#lightblue] <i><size:12>Complexity and Learning Curve
***[#yellow] <i><size:12>Cloud-native development requires new skills, tools, and practices that may take time to learn and adopt
***[#yellow] <i><size:12>Managing complex distributed systems can be challenging and requires a new mindset
**[#lightblue] <i><size:12>Operational Overhead
***[#yellow] <i><size:12>Cloud-native applications require more operational management and monitoring to ensure reliability and performance
***[#yellow] <i><size:12>Teams need to invest in automation and tooling to manage cloud-native environments at scale
**[#lightblue] <i><size:12>Vendor Lock-In
***[#yellow] <i><size:12>Cloud-native technologies and services may create a dependency on a particular cloud provider
***[#yellow] <i><size:12>Teams need to carefully consider the tradeoffs of using cloud-native services and be prepared for potential migration challenges

*[#darkblue] <color #white><i>Best Practices
**[#lightblue] <i><size:12>Use a Container Orchestration Platform
***[#yellow] <i><size:12>Kubernetes is the most popular container orchestration platform and provides a rich set of features for managing cloud-native applications
***[#yellow] <i><size:12>Other options include Docker Swarm, Amazon ECS, and Google Kubernetes Engine
**[#lightblue] <i><size:12>Adopt Infrastructure as Code
***[#yellow] <i><size:12>Define infrastructure using code and use version control to manage changes
***[#yellow] <i><size:12>Use automated pipelines to deploy infrastructure changes
**[#lightblue] <i><size:12>Leverage Cloud-Native Services
***[#yellow] <i><size:12>Cloud-native services like databases, storage, and messaging can accelerate development and reduce operational overhead
***[#yellow] <i><size:12>Choose services that are compatible with your container orchestration platform and can be easily integrated into your application
**[#lightblue] <i><size:12>Use Monitoring and Observability Tools
***[#yellow] <i><size:12>Implement monitoring and observability early in the development process to ensure reliability and performance
***[#yellow] <i><size:12>Use tools like Prometheus, Grafana, and Jaeger to monitor metrics, logs, and traces
**[#lightblue] <i><size:12>Embrace DevOps Practices
***[#yellow] <i><size:12>Build a culture of collaboration and shared responsibility between development and operations teams
***[#yellow] <i><size:12>Use automation and continuous delivery to streamline development

**[#lightblue] <i><size:18>[[docs/cloud-computing/Cloud-Design-Patterns.puml Design for Resilience and Fault Tolerance]]
***[#yellow] <i><size:12>Cloud-native applications are designed to be resilient to failures and can automatically recover from them
***[#a] <i><size:12>Use **[[docs/cloud-computing/Cloud-Design-Patterns.puml fault-tolerant design patterns]]** and consider implementing <b>[[docs/cloud-computing/Cloud-Design-Patterns.puml circuit breakers and retry mechanisms]]
**[#lightblue] <i><size:12>Secure Your Application and Infrastructure
***[#yellow] <i><size:12>Implement strong authentication and authorization mechanisms
***[#yellow] <i><size:12>Use encryption to protect data in transit and at rest
***[#yellow] <i><size:12>Regularly test your application and infrastructure for vulnerabilities and implement security best practices
**[#lightblue] <i><size:12>Optimize Resource Usage
***[#yellow] <i><size:12>Use container resource limits to ensure optimal resource utilization
***[#yellow] <i><size:12>Implement autoscaling to scale up or down based on demand
***[#yellow] <i><size:12>Optimize your application code and infrastructure to reduce resource usage and costs
**[#lightblue] <i><size:12>Plan for Disaster Recovery and Business Continuity
***[#yellow] <i><size:12>Implement backup and restore procedures to ensure data is recoverable in case of disaster
***[#yellow] <i><size:12>Have a plan in place for how to respond to unexpected events and ensure lightblue continuity
**[#lightblue] <i><size:12>Document and Share Knowledge
***[#yellow] <i><size:12>Document your architecture, infrastructure, and processes to ensure knowledge is shared and easily accessible
***[#yellow] <i><size:12>Use collaboration tools to facilitate communication and knowledge sharing between team members

@endmindmap