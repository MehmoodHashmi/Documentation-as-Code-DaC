@startmindmap
title =<i><u>Cloud Native\n<img:images/img.png>

* <i><size:14><b>[[https://learn.microsoft.com/en-us/dotnet/architecture/cloud-native/definition What is Cloud Native?]] Microsoft Article
!theme hacker


*[#darkblue] <color #white><i>Definition
**[#lightblue] <i><size:14>A software development approach that emphasizes building applications specifically for cloud environments
**[#lightblue] <i><size:14>Cloud-native applications are designed to be scalable, resilient, and easily managed in dynamic and distributed environments

*[#darkblue] <color #white><i>Key Principles
**[#lightblue] <i><size:14>Microservices Architecture
***[#yellow] <i><size:14>Application is composed of small, independent services that can be developed, deployed, and scaled independently
***[#yellow] <i><size:14>Each service runs in its own process and communicates with other services using lightweight mechanisms
**[#lightblue] <i><size:14>Containerization
***[#yellow] <i><size:14>Applications are packaged as containers, which provide a lightweight and portable runtime environment
***[#yellow] <i><size:14>Containers can be easily deployed, scaled, and managed across different environments
**[#lightblue] <i><size:14>[[docs/3-devops/devops-plantuml-mindmap/advance-infrastructure-as-code.puml Infrastructure as Code]]
***[#yellow] <i><size:14>Infrastructure is defined and managed using code, which makes it easier to automate and manage at scale
***[#yellow] <i><size:14>Changes to infrastructure can be version-controlled and deployed using automated pipelines
**[#lightblue] <i><size:14>[[docs/3-devops/devops-plantuml-mindmap/DevOps.puml DevOps]]
***[#yellow] <i><size:14>Culture and practices that emphasize collaboration and automation between development and operations teams
***[#yellow] <i><size:14>DevOps enables teams to deliver software faster, with higher quality, and more reliably

*[#darkblue] <color #white><i>Benefits
**[#lightblue] <i><size:14>Scalability and Resilience
***[#yellow] <i><size:14>Cloud-native applications can handle large and unpredictable workloads by scaling up or down as needed
***[#yellow] <i><size:14>Applications are designed to be resilient to failures and can automatically recover from them
**[#lightblue] <i><size:14>Agility and Time-to-Market
***[#yellow] <i><size:14>Cloud-native development enables faster release cycles and allows teams to respond quickly to changing lightblue requirements
***[#yellow] <i><size:14>Teams can experiment and innovate more easily using cloud-native technologies and services
**[#lightblue] <i><size:14>Cost Efficiency
***[#yellow] <i><size:14>Cloud-native applications can be more cost-effective by leveraging cloud resources more efficiently
***[#yellow] <i><size:14>Containerization enables better resource utilization and reduces infrastructure overhead

*[#darkblue] <color #white><i>Cloud-Native Technologies
**[#lightblue] <i><size:14>Container Orchestration
***[#yellow] <i><size:14>Kubernetes
***[#yellow] <i><size:14>Docker Swarm
**[#lightblue] <i><size:14>Service Mesh
***[#yellow] <i><size:14>Istio
***[#yellow] <i><size:14>Linkerd
**[#lightblue] <i><size:14>Cloud-Native Databases
***[#yellow] <i><size:14>Amazon DynamoDB
***[#yellow] <i><size:14>Google Cloud Spanner
***[#yellow] <i><size:14>MongoDB Atlas
**[#lightblue] <i><size:14>Cloud-Native Storage
***[#yellow] <i><size:14>Amazon S3
***[#yellow] <i><size:14>Google Cloud Storage
***[#yellow] <i><size:14>Azure Blob Storage
**[#lightblue] <i><size:14>Serverless Computing
***[#yellow] <i><size:14>AWS Lambda
***[#yellow] <i><size:14>Google Cloud Functions
***[#yellow] <i><size:14>Azure Functions

*[#darkblue] <color #white><i>Challenges
**[#lightblue] <i><size:14>Complexity and Learning Curve
***[#yellow] <i><size:14>Cloud-native development requires new skills, tools, and practices that may take time to learn and adopt
***[#yellow] <i><size:14>Managing complex distributed systems can be challenging and requires a new mindset
**[#lightblue] <i><size:14>Operational Overhead
***[#yellow] <i><size:14>Cloud-native applications require more operational management and monitoring to ensure reliability and performance
***[#yellow] <i><size:14>Teams need to invest in automation and tooling to manage cloud-native environments at scale
**[#lightblue] <i><size:14>Vendor Lock-In
***[#yellow] <i><size:14>Cloud-native technologies and services may create a dependency on a particular cloud provider
***[#yellow] <i><size:14>Teams need to carefully consider the tradeoffs of using cloud-native services and be prepared for potential migration challenges

*[#darkblue] <color #white><i>Best Practices
**[#lightblue] <i><size:14>Use a Container Orchestration Platform
***[#yellow] <i><size:14>Kubernetes is the most popular container orchestration platform and provides a rich set of features for managing cloud-native applications
***[#yellow] <i><size:14>Other options include Docker Swarm, Amazon ECS, and Google Kubernetes Engine
**[#lightblue] <i><size:14>Adopt Infrastructure as Code
***[#yellow] <i><size:14>Define infrastructure using code and use version control to manage changes
***[#yellow] <i><size:14>Use automated pipelines to deploy infrastructure changes
**[#lightblue] <i><size:14>Leverage Cloud-Native Services
***[#yellow] <i><size:14>Cloud-native services like databases, storage, and messaging can accelerate development and reduce operational overhead
***[#yellow] <i><size:14>Choose services that are compatible with your container orchestration platform and can be easily integrated into your application
**[#lightblue] <i><size:14>Use Monitoring and Observability Tools
***[#yellow] <i><size:14>Implement monitoring and observability early in the development process to ensure reliability and performance
***[#yellow] <i><size:14>Use tools like Prometheus, Grafana, and Jaeger to monitor metrics, logs, and traces
**[#lightblue] <i><size:14>Embrace DevOps Practices
***[#yellow] <i><size:14>Build a culture of collaboration and shared responsibility between development and operations teams
***[#yellow] <i><size:14>Use automation and continuous delivery to streamline development

**[#lightblue] <i><size:18>[[docs/cloud-computing/Cloud-Design-Patterns.puml Design for Resilience and Fault Tolerance]]
***[#yellow] <i><size:14>Cloud-native applications are designed to be resilient to failures and can automatically recover from them
***[#a] <i><size:14>Use **[[docs/cloud-computing/Cloud-Design-Patterns.puml fault-tolerant design patterns]]** and consider implementing <b>[[docs/cloud-computing/Cloud-Design-Patterns.puml circuit breakers and retry mechanisms]]
**[#lightblue] <i><size:14>Secure Your Application and Infrastructure
***[#yellow] <i><size:14>Implement strong authentication and authorization mechanisms
***[#yellow] <i><size:14>Use encryption to protect data in transit and at rest
***[#yellow] <i><size:14>Regularly test your application and infrastructure for vulnerabilities and implement security best practices
**[#lightblue] <i><size:14>Optimize Resource Usage
***[#yellow] <i><size:14>Use container resource limits to ensure optimal resource utilization
***[#yellow] <i><size:14>Implement autoscaling to scale up or down based on demand
***[#yellow] <i><size:14>Optimize your application code and infrastructure to reduce resource usage and costs
**[#lightblue] <i><size:14>Plan for Disaster Recovery and Business Continuity
***[#yellow] <i><size:14>Implement backup and restore procedures to ensure data is recoverable in case of disaster
***[#yellow] <i><size:14>Have a plan in place for how to respond to unexpected events and ensure lightblue continuity
**[#lightblue] <i><size:14>Document and Share Knowledge
***[#yellow] <i><size:14>Document your architecture, infrastructure, and processes to ensure knowledge is shared and easily accessible
***[#yellow] <i><size:14>Use collaboration tools to facilitate communication and knowledge sharing between team members

@endmindmap