@startmindmap
title =<b><i>Operating Systems\n<img:images/img_11.png> <img:images/img_3.png>
!theme hacker

*[#darkblue] <color #white><i><size:14> Introduction
**[#lightblue] <b><color #black><i><size:14>Definition of an Operating System
**[#lightblue] <b><color #black><i><size:14>Evolution of Operating Systems
**[#lightblue] <b><color #black><i><size:14>Functions of an Operating System
*[#darkblue] <color #white><i><size:38>Processes & Threads\n<img:images/img.png>
**[#lightblue] <b><color #black><i><size:14>Process Management
***[#green] <b><color #white><i><size:24>Process Scheduling (algorithms):\n<img:images/img_2.png>
****[#darkorange] <b><color #black><i><size:14>1- Preemptive Scheduling (algorithms):\n*<b><color #black><i><size:14>Resources <color #white>(CPU & RAM)</color> <size:14><color:black><i> are allocated to a "process" for a specified period of of time.
****[#darkorange] <b><color #black><i><size:14>2- Non-Preemptive Scheduling (algorithms):\n*<b><color #black><i><size:14>Once <color #white>resources (CPU & RAM)</color> <size:14><color:black><i> are allocated to a "process", the "process" maintains \n<b><color #black><i><size:14>the "control" until it "completes or transitions" to a "waiting state".
****[#yellow] <color #black><i><size:14><b>Round robin scheduling
****[#yellow] <color #black><i><size:14><b>Priority Scheduling (H, M, L)
****[#yellow] <color #black><i><size:14><b>Shortest remaining time
****[#yellow] <color #black><i><size:14><b>FIFO
****[#yellow] <color #black><i><size:14><b>Shortest job next
****[#yellow] <color #black><i><size:14><b>Highest response ratio next
****[#yellow] <color #black><i><size:14><b>Multi-Level feedback queue
****[#yellow] <color #black><i><size:14><b>Round robin(rr) scheduling
****[#yellow] <color #black><i><size:14><b>Preemptive priority cpu scheduling
***[#green]:<b><color #white><i><size:17>Interprocess Communication <b><color #white><i><size:14>(Two widely used methods:)
*<color #white><b><i><size:16>Shared Memory
*<color #white><b><i><size:16>Message-Passing
<b><color #white><i><size:14>Other methods:
**<b><color #white><i><size:14>Semaphores
**<b><color #white><i><size:14> Signals etc.
<img:images/img_1.png>;
****[#yellow] <color #black><i><size:24><b>Process ID & Port number\n<img:images/img_12.png>
***[#green] <b><color #white><i><size:14>Process Synchronization
**[#lightblue] <b><color #black><i><size:14>Thread Management
***[#green] <b><color #white><i><size:14>Thread Scheduling
***[#green] <b><color #white><i><size:14>Thread Synchronization
***[#gold] <b><color #black><i><size:14>Thread Block Storage (TBS):
****[#yellow] <color #black><i><size:14><b>is a data-structure, something like "Process Control Block"
**[#lightblue] <b><color #black><i><size:14>Deadlock and Starvation
*[#darkblue] <color #white><i><size:34>Memory Management\n<img:images/img_4.png>\n\n<img:images/img_13.png>
**[#lightblue] <b><color #black><i><size:24>Memory Hierarchy\n<img:images/img_10.png>
**[#lightblue] <b><color #black><i><size:14>Address Binding
***[#green] <b><color #white><i><size:14>Address Translation
****[#yellow]:<color #black><i><size:14>**Page map table** is a **data structure** that keeps track of the relations between a **"page of a process"** and a **frame in physical memory.**
*<color #black><i><size:14>**Page address:** also known as **logical address** is represented by "page number and offset". Thus, <b>Logical Address = Page number + page offset
*<color #black><i><size:14>**Frame address:** also known as **physical address** is represented by "frame number and offset". Thus, <b>Physical Address = Frame number + page offset
<img:images/img_5.png>
*<color #black><i><size:14>When allocating a frame to any page, the system translates the logical address into a physical address, creating an entry into the page table which can
<color #black><i><size:14>be used throughout the process of execution. The system loads the corresponding pages of a process into the available memory frames during execution.

*<color #black><i><size:14>If a system runs out of RAM, the OS moves the idle or unwanted pages of a memory to the secondary memory. This frees up RAM for other processes to us &
<color #black><i><size:14>the OS also brings back these processes when the program needs them. This continues until the execution of a process gets complete.;

**[#lightblue] <b><color #black><i><size:34>Memory Allocation\n<img:images/img_9.png>
***[#green] <b><color #white><i><size:14>Static Allocation
***[#green] <b><color #white><i><size:14>Dynamic Allocation
****[#yellow] <color #black><i><size:14>First-Fit Algorithm
****[#yellow] <color #black><i><size:14>Best-Fit Algorithm
****[#yellow] <color #black><i><size:14>Worst-Fit Algorithm
****[#yellow] <color #black><i><size:14>Buddy Algorithm
**[#lightblue] <b><color #black><i><size:34>Memory Paging\n<img:images/img_6.png>
***[#green] <b><color #white><i><size:14>Page Replacement Algorithms
****[#yellow] <color #black><i><size:14>FIFO Algorithm
****[#yellow] <color #black><i><size:14>Optimal Algorithm
****[#yellow] <color #black><i><size:14>LRU Algorithm
****[#yellow] <color #black><i><size:14>Clock Algorithm
***[#green] <b><color #white><i><size:14>Segmentation
***[#green] <b><color #white><i><size:14>Virtual Memory
****[#yellow] <color #black><i><size:14>**Virtual Memory:** some portion of **solid state drive (SSD)** is used as <b>RAM
****[#yellow] <color #black><i><size:14>Demand Paging
****[#yellow] <color #black><i><size:14>Page Fault
****[#yellow] <color #black><i><size:14>Page Replacement
****[#yellow] <color #black><i><size:14>Page Replacement Algorithms
*****[#gold] <color #black><i><size:14>LRU Algorithm
*****[#gold] <color #black><i><size:14>Clock Algorithm
*****[#gold] <color #black><i><size:14>Second Chance Algorithm
*****[#gold] <color #black><i><size:14>NFU Algorithm
*****[#gold] <color #black><i><size:14>Aging Algorithm
**[#lightblue] <b><color #black><i><size:24>Fragmentation\n<img:images/img_7.png>\n\n<img:images/img_8.png>
***[#green] <b><color #white><i><size:14>External Fragmentation
***[#green] <b><color #white><i><size:14>Internal Fragmentation
*[#darkblue] <color #white><i><size:14> File Systems
**[#lightblue] <b><color #black><i><size:14>File Concepts
**[#lightblue] <b><color #black><i><size:14>File Access Methods
**[#lightblue] <b><color #black><i><size:14>File Allocation Methods
***[#green] <b><color #white><i><size:14>Contiguous Allocation
***[#green] <b><color #white><i><size:14>Linked Allocation
***[#green] <b><color #white><i><size:14>Indexed Allocation
****[#yellow] <color #black><i><size:14>Single-Level Indexing
****[#yellow] <color #black><i><size:14>Two-Level Indexing
****[#yellow] <color #black><i><size:14>Multi-Level Indexing
**[#lightblue] <b><color #black><i><size:14>Directory Structure
***[#green] <b><color #white><i><size:14>Single-Level Directory
***[#green] <b><color #white><i><size:14>Two-Level Directory
***[#green] <b><color #white><i><size:14>Tree-Structured Directory
***[#green] <b><color #white><i><size:14>Acyclic-Graph Directory
**[#lightblue] <b><color #black><i><size:14>File System Implementation
***[#green] <b><color #white><i><size:14>Disk Management
****[#yellow] <color #black><i><size:14>Disk Formatting
****[#yellow] <color #black><i><size:14>Disk Partitioning
****[#yellow] <color #black><i><size:14>Boot Block
****[#yellow] <color #black><i><size:14>Master Boot Record
***[#green] <b><color #white><i><size:14>File System Interface
***[#green] <b><color #white><i><size:14>File System Mounting
***[#green] <b><color #white><i><size:14>File System Performance
*[#darkblue] <color #white><i><size:14> Inpu/Output Systems
**[#lightblue] <b><color #black><i><size:14>Device Management
***[#green] <b><color #white><i><size:14>Device Driver
***[#green] <b><color #white><i><size:14>Interrupt Handling
***[#green] <b><color #white><i><size:14>Direct Memory Access (DMA)
**[#lightblue] <b><color #black><i><size:14>I/O Scheduling
***[#green] <b><color #white><i><size:14>FCFS Algorithm
***[#green] <b><color #white><i><size:14>Priority Algorithm
***[#green] <b><color #white><i><size:14>Shortest Seek Time First Algorithm
***[#green] <b><color #white><i><size:14>SCAN Algorithm
***[#green] <b><color #white><i><size:14>C-SCAN Algorithm
*[#darkblue] <color #white><i><size:14> Security and Protection
**[#lightblue] <b><color #black><i><size:14>Threats and Attacks
**[#lightblue] <b><color #black><i><size:14>Authentication
**[#lightblue] <b><color #black><i><size:14>Authorization
**[#lightblue] <b><color #black><i><size:14>Access Control
**[#lightblue] <b><color #black><i><size:14>Encryption and Decryption
**[#lightblue] <b><color #black><i><size:14>Firewalls
**[#lightblue] <b><color #black><i><size:14>Intrusion Detection and Prevention
**[#lightblue] <b><color #black><i><size:14>Security Management
*[#darkblue] <color #white><i><size:22> Virtualization
**[#lightblue] <b><color #black><i><size:18>Virtual Machines
**[#lightblue] <b><color #black><i><size:18>Hypervisors
**[#lightblue] <b><color #black><i><size:14>Emulation
**[#lightblue] <b><color #black><i><size:22>[[docs/3-devops/devops-plantuml-mindmap/Docker.puml Containerization]]
*[#darkblue] <color #white><i><size:14> Types of Operating Systems
**[#lightblue] <b><color #black><i><size:14>Batch Operating System
**[#lightblue] <b><color #black><i><size:14>Time-Sharing Operating System
**[#lightblue] <b><color #black><i><size:14>Real-Time Operating System
**[#lightblue] <b><color #black><i><size:14>Distributed Operating System
@endmindmap
