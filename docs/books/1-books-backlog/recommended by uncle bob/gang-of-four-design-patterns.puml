@startmindmap

title Design Patterns: Elements of Reusable Object-Oriented Software [Gang of Four]

* Creational Patterns
** Abstract Factory
*** Provides an interface for creating families of related objects without specifying their concrete classes
** Builder
*** Separates the construction of a complex object from its representation, allowing the same construction process to create different representations
** Factory Method
*** Defines an interface for creating objects, but lets subclasses decide which classes to instantiate
** Prototype
*** Specifies the kinds of objects to create using a prototypical instance, and then creates new objects by copying this prototype
** Singleton
*** Ensures a class has only one instance, and provides a global point of access to it

* Structural Patterns
** Adapter
*** Converts the interface of a class into another interface the clients expect, allowing classes to work together that could not otherwise
** Bridge
*** Decouples an abstraction from its implementation, allowing them to vary independently
** Composite
*** Composes objects into tree structures to represent part-whole hierarchies, allowing clients to treat individual objects and compositions uniformly
** Decorator
*** Attaches additional responsibilities to an object dynamically, providing a flexible alternative to subclassing for extending functionality
** Facade
*** Provides a unified interface to a set of interfaces in a subsystem, simplifying the subsystem for clients
** Flyweight
*** Uses sharing to support large numbers of fine-grained objects efficiently

* Behavioral Patterns
** Chain of Responsibility
*** Avoids coupling the sender of a request to its receiver by giving more than one object a chance to handle the request
** Command
*** Encapsulates a request as an object, allowing the parameterization of clients with different requests, queue or log requests, and support undoable operations
** Interpreter
*** Defines a representation for grammar of a language and provides an interpreter for interpreting the language
** Iterator
*** Provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation
** Mediator
*** Defines simplified communication between objects, allowing them to cooperate without being tightly coupled
** Memento
*** Captures and externalizes an object's internal state, allowing the object to be restored to this state later
** Observer
*** Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically
** State
*** Allows an object to alter its behavior when its internal state changes, wrapping behavior and state into separate objects and allowing for easy maintenance and extension
** Strategy
*** Defines a family of algorithms, encapsulates each one, and makes them interchangeable, allowing algorithms to vary independently from clients that use them
** Template Method
*** Defines the skeleton of an algorithm in a method, deferring some steps to subclasses, allowing subclasses to redefine certain steps of an algorithm without changing its structure
** Visitor
*** Separates an algorithm from an object structure by moving the hierarchy of methods into one object, allows adding new operations without changing the classes of the objects on which it operates

@endmindmap
