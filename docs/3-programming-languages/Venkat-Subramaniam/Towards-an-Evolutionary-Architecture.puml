@startmindmap
title =<i><b><u><size:18>Towards an Evolutionary Architecture
* <i><b>[[docs/3-programming-languages/Venkat-Subramaniam/Core-Software-design-principles-for-software-developers.puml Core Software design principles for software developers by Venkat Subramaniam]]
!theme hacker

*[#darkblue] <color:white><i>Towards an Evolutionary\n<color:white><i>Architecture
**[#lightblue] <i><color #black><size:12>What's architecture? [[docs/3-programming-languages/Venkat-Subramaniam/images/img_139.png click me]]\n<img:images/img_139.png{scale=.4}>
***[#green] <i><color #white><b><size:12>Definition
****[#a] <i><color #black><size:12><b>[[docs/3-programming-languages/Venkat-Subramaniam/app-vs-network-structure.puml Shape of the major structure of a system or topology. architecture is a "view" of a system.]] click me
****[#yellow]:<i><color #black><size:12>**Goal of architecture:** Minimize the **human resources** required to **build & maintain** "software system".
*<i><color #black><size:12>If **effort** remains **constant or shrinks with time** then **design** is **good**. If **effort** increases with each **passing release** then **design** is <b>bad.;
****[#yellow] <i><color #black><size:12>**Martin fowler** article, "Who needs an architect". <b>Said: It is
*****[#darkorange] <b><i><color #black><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_252.png Shared understanding between the senior team members of a system.]] click
****[#green] *<b><i><color #white><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_271.png Software Engineering in the Cloud]] <&cloud> click me \n*<b><i><color #white><size:12>[[docs/3-programming-languages/clean-architecture/images/img.png Software Architecture the Hard Parts]] click me

***[#green]:<b><i><color #white><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_134.jpg Why evolutionary architecture? click me]]
<img:images/img_1.jpg{scale=.222}>
*<b><i><color #white><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_541.png Next Architecture?]];

****[#a]:*<b><i><color #black><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_27.png Clean Architecture]] click me
*<b><i><color #black><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_58.jpg Onion Architecture]] click me
*<i><color #black><size:12><b>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_26.png Hexagonal Architecture + DDD]] click me
*<i><color #black><size:12><b>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_97.png Domain Driven Design DDD]] click me
==<i><color #black><size:14><b>Building & Designing Software==
*<b><i><color #black><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_63.png Who builds & designs the software?]] click me
*<b><i><color #black><size:12>[[docs/cloud-computing/AWS-Cloud/Software_Architecture_Mindmap.png Software Architecture fundamentals Mindmap]];
*****[#darkorange] <i><color #black><size:12>**--BUFD--** is waterfall \n*<i><color #black><size:12>**[[docs/3-programming-languages/Venkat-Subramaniam/images/img_556.png No, it is not BUFD?]]**
******[#a] *<i><color #black><size:12><b>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_255.png Agile vs DevOps vs SRE]] & [[docs/3-devops/devops-plantuml-mindmap/Site-Reliability-Engineering-(SRE).puml SRE Mindmap & Observability]] \n*<i><color #black><b><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/gif/conventional-SDLC-vs-DevOps-vs-NoOps.adoc Conventional SDLC vs. DevOps Vs. NoOps]] gif \n*<i><color #black><b><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/gif/how-companies-ship-code.adoc How Companies ship code?]] gif

*****[#yellow] <i><color #black><size:12>Agile (No Design) is <b>disaster!
******[#a] <b><i><color #black><size:12>[[a Clean Agile]]
*****[#yellow] <i><color #black><size:12><b>EUFD <&check>

***[#green]:<i><color #white><b><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_73.png S/W Architecture]]
*<b><i><color #black><size:10><color:white>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_541.png Next Architecture]]
*<b><i><color #black><size:10><color:white>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_542.png Defer Decisions]]
*<b><i><color #black><size:10><color:white>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_562.png Premature decisions]];
****[#black] <b><i><color #black><size:10>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_291.png Screaming architecture]]
****[#black] <b><i><color #black><size:10>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_273.png 2-Laws of S/W architecture]]
****[#darkorange] <b><i><color #black><size:11>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_175.png Scaffolding vs Design]]
****[#a] <b><i><color #black><size:13>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_75.png 1- Design pattern]]
****[#a] <b><i><color #black><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/integration-style.puml 2- Integration Style]]
****[#a] <b><i><color #black><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_77.png 3- pattern]]
****[#a] <b><i><color #black><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_179.png 4- Anti-pattern]]
****[#a] <b><i><color #black><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_245.png Knowledge triangle]]
****[#a]:*<b><i><color #black><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_247.png 4+1 View Model]]
*<b><i><color #black><size:11>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_527.png Why 4+1 View Model?]]
**<b><i><color #black><size:11>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_528.png Part-2]] & [[docs/3-programming-languages/Venkat-Subramaniam/images/img_529.png Grady Booch]]
====
<b><i><color #black><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_3.jpg Quality Categorization]]
*<b><i><color #black><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/gif/conventional-SDLC-vs-DevOps-vs-NoOps.adoc DevOps]] (Dev & Ops);

****[#darkorange] <b><i><color #black><size:10>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_283.png Mutability & Architecture]]
****[#darkorange] <b><i><color #black><size:10>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_256.png Architecture refactoring]] \n*<b><i><color #black><size:10>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_512.png Module Refactoring]]
***[#green] <b><i><color #white><size:14>In Software Development we often say:
****[#a]:*<b><i><color #black><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_138.png Capture requirements]]
====
*<b><i><color #black><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_5.jpg 3-Levels of requirements]]
<b><i><color #black><size:10>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_530.png Analysis & Design duration vs.]]
<b><i><color #black><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_530.png Implementation duration]];

*****[#a]:*<b><i><color #black><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_242.png Requirements Engineering Process Maturity Model]]
*<b><i><color #black><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_244.png CMMI version-2]] & [[docs/3-programming-languages/Venkat-Subramaniam/images/img_439.png S/W Project Estimation (Robert C Martin)]]
*<b><i><color #black><size:12>[[docs/3-programming-languages/clean-architecture/images/image-2023-02-20-18-57-28-106.png S/W Project Cost Estimation Technique based on Use Case Points]];

******[#a]:<b><i><color #black><size:12>[[https://docs.google.com/document/d/1yBJZUMnXvuQWVgM9HTpH0VHwaUutjbFmHIjZrzKLMVA/edit Try BDD]] google docs
*<b><i><color #black><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_282.png Template]] share google doc with client
*<b><i><color #black><size:12>[[https://cucumber.io/blog/bdd/better-requirements-by-harnessing-the-power-of-exa/ Better requirements by harnessing the power of examples]] article
*<b><i><color #black><size:12>[[https://cucumber.io/blog/bdd/bdd-with-event-mapping/ BDD with Event Mapping]] article;

****[#a]:*<b><i><color #black><size:12>[[docs/1-business-analyst/requirements-management.puml Gather requirements]]
====
<b><i><color #black><size:12>[[docs/1-Requirement-Engineering/MVP-PoC-and-case-study/UI-UX.puml UI/UX vs. Use Case]] & [[docs/3-programming-languages/Venkat-Subramaniam/images/img_267.png Framework]] is (
<b><i><color #black><size:9>Spring, Springboot, struts, Micronaut, not tomcat)
*<b><i><color #black><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_532.png GUI is not Use-Cases]]
**<b><i><color #black><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_534.png UX Design]]
**<b><i><color #black><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_533.png UI Design]]
**<b><i><color #black><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_535.png IA Info Architecture]]
**<b><i><color #black><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_536.png ID Interaction Design]];
*****[#a]:<b><i><color #black><size:12>[[docs/1-business-analyst/project-management/project-management.puml Project Management]] & [[docs/3-programming-languages/Venkat-Subramaniam/pdf/software-requirements.pdf Software Requirements Book]] 2-pages [[docs/3-programming-languages/Venkat-Subramaniam/images/img_538.png Use Case Development Top-down or Bottom-Up? Part-1]], [[docs/3-programming-languages/Venkat-Subramaniam/images/img_561.png Part-2]],  & [[docs/3-programming-languages/Venkat-Subramaniam/images/img_539.png Use Case 2.0 Work Products]] & [[docs/3-programming-languages/Venkat-Subramaniam/images/img_540.png Use Case Limitations]]
|<b><i><color #black><size:12>[[docs/3-programming-languages/clean-architecture/images/use-case-modeling.png Traditional use case modeling]] vs [[docs/3-programming-languages/Venkat-Subramaniam/images/img_171.png Use Case 2.0 Modeling Part-1]], [[docs/3-programming-languages/Venkat-Subramaniam/images/img_345.png Part-2]], & [[docs/3-programming-languages/Venkat-Subramaniam/images/img_211.png Work Products]] & [[docs/3-programming-languages/Venkat-Subramaniam/images/img_287.png Use Case variations]] & [[docs/3-programming-languages/Venkat-Subramaniam/images/img_128.jpg UML cheatsheet]]|<#blue><b><i>[[docs/2-uml/requirements-and-design-with-plantuml/1-use-cases-or-features/use-case.png Use-Case vs webservice]]|
|<b><i><color #black><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/Identification-of-a-use-case.puml Identification of a Use Case]] & [[docs/3-programming-languages/Venkat-Subramaniam/images/img_355.png Use Case 2.0 Test Cases]] & [[docs/3-programming-languages/Venkat-Subramaniam/images/img_356.png Principles of Use Case 2.0, activities for (iterative or incremental) development]]|<#red><b><i>[[docs/3-programming-languages/clean-architecture/images/Screenshot_33.png Use-Case Templates]]|
|<b><i><color #black><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/images/BDD-Vs-TDD.drawio.png BDD vs. TDD Part-1]] & [[docs/3-programming-languages/Venkat-Subramaniam/images/img_427.png BDD Part-2 Naveen-Automation-Lab]] & [[docs/3-programming-languages/Venkat-Subramaniam/images/img_426.png TDD vs. BDD vs ATDD naveen-automation-lab]] & [[docs/3-programming-languages/Venkat-Subramaniam/images/ATDD-vs-TDD-robert-c-martin.drawio.png TDD vs. BDD vs. ATDD Robert C Martin]]|<#black><i><b>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_525.png Use-Case Vs. CRUD]]|
*<b><i><color #black><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_543.png Some useful models for representing certain types of system information]];
****[#yellow] <i><color #black><size:12>Observer effect
*****[#yellow] *<i><color #black><size:12>Does client's problem requires research? Or did he asked for doing research? <b>If yes, then requires more cost & time \n*<i><color #black><size:12>Providing solution to a problem without doing research & after research are two different processes
****[#gold] *<i><color #black><size:12>If you want to build what your customers wanted, you will <b>fail.\n*<i><color #black><size:12>You need to build what your customers still want.
****[#yellow] <i><color #black><size:13>Build working software.
*****[#gold] <i><color #black><size:12>Half of the total programmers in the world can do it
*****[#gold] <i><color #black><size:12>But I want to build <b>relevant working software\n*<b><i><color #black><size:12>Requires more effort
****[#a] <i><color #black><size:13><b>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_251.png PowerPoint Architect]] \n*<i><color #black><size:13><b>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_431.png Ivory Tower]] \n*<i><color #black><size:12><b>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_446.png Architect & Devloper]]
*****[#yellow] <i><color #black><size:12><b>When we Say an Architect must code, the goal is not they should sit & code. Then why are we saying they should code? Because you want \n<i><color #black><size:12><b>them to get insight at the low levels so that when they make decisions at the higher levels, they are not limiting what you can do. Those \n<i><color #black><size:12><b>constraints their knowledge, visibility & understanding is what you count on. \n*<i>Doing **"Pair Programing"** with <b>developers!
****[#darkorange] *<i><color #black><size:15><b>No one cares if you write good code
*****[#grey]:*<i><color #black><size:22><b>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_59.png Does this code saves or makes money?]] & [[docs/3-programming-languages/Venkat-Subramaniam/images/img_559.png Answer-1]]
*<i><color #black><size:22><b>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_59.png Add value via buy/save more time for client]] & [[docs/3-programming-languages/Venkat-Subramaniam/images/img_560.png Answer-2]];
******[#grey] <i><color #black><size:22><b>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_59.png Education vs. Knowledge?]]
**[#lightblue] <i><color #black><size:12><b>Two values of software
***[#green] <i><color #white><size:12><b>Behavioral value
****[#yellow]:|<#white><i><color #black><size:12>help  **stakeholders** <b>"make or save money".</b> Is actually **use cases** or <b>feature development. (& problem solving)|
**<i><color #black><size:12>by **making machines behave** in ways that **satisfy** the <b>requirement.
*<i><color #black><size:12>Many **programmers** believe this is the entirely of their <b>job. They are sadly mistaken.;
***[#green] <i><color #white><size:12><b>Structural value
****[#yellow]:<i><color #black><size:12>is **architecture** & often ignored by the <b>developers
====
*<i><color #black><size:12>**Architecture:** Soft-ware is a compound word
*<i><color #black><size:12>When **stakeholders** change their **minds** the **"change"** to the "software" should be <b>"simple & easy" to make.
*<i><color #black><size:12>The **cost of change** should be **proportional** to <b>scope (range), not shape.;
****[#yellow]:|<#white><i><color #black><size:12><b><u>Scope Vs Shape:|
*<i><color #black><size:12>**Stakeholders** believe that the **requirements & changes** are only **complicated** by <b>scope.
*<i><color #black><size:12>**Programmers** see each new **requirements** as a **puzzle piece** that must be **fit** into an <b>ever more complex puzzle.
|<#white><i><color #black><size:12>**Solution:** keep the puzzle **"simple".**|;
***[#a]:<i><color #black><size:12><b>The book Cathedral & bazaar in late 1990's said two values of software are:
<i><color #black><size:12><b>1- Use value
<i><color #black><size:12><b>2- Sale value
==<i><color #black><size:14><b>After the rise of [[docs/AI-ML-DL-Data-Science-and-BigData/machine-learning-ML/Modern-Machine-Learning.puml Modern Machine Learning]] ([[docs/AI-ML-DL-Data-Science-and-BigData/machine-learning-ML/3-deep-learning-DL/Deep-Learning.puml & Deep Learning]])==
*<i><color #black><size:12><b>Data [[docs/AI-ML-DL-Data-Science-and-BigData/big-data/big-data.puml (Big Data)]] has "value".;
**[#lightblue] <i><color #black><size:12>The risk of not evolving
***[#green] <b><i><color #white><size:12>Relevance
****[#gold]:*<i><color #black><size:12>If not evolved may become obsolete & irrelevant.
<i><color #black><size:12>**1-** Team is held hosted by the architects, architect says you will develop it because we architected it.
<i><color #black><size:12>**2-** System does one thing & architecture diagrams on the walls does completely different things, they
<i><color #black><size:12>deliver a "working system" which is not in **sync** with its <b>architecture;
***[#green] <b><i><color #white><size:12>Governance
****[#gold] *<i><color #black><size:12>**Architecture committee,** slows down the process & "initial architecture" draft becomes useless.
**[#lightblue] <i><color #black><size:12>The risk of  evolving
***[#green] <b><i><color #white><size:12>What if we can't \n<b><i><color #white><size:12>support a feature?
****[#yellow] *<i><color #black><size:12><b>Planned Features
*****[#yellow] *<i><color #black><size:12>Things you know, you will work on, in the beginning of the project you had project backlog. \n<i><color #black><size:12>A list of requirements given to you.
*****[#a] *<i><color #black><size:12>Find the following for each <b>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_448.png user story:]]\n<i><color #black><size:12><b>1- Business value \n<i><color #black><size:12><b>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_448.png 2- Architecture Impact]]\n*<i><color #black><size:12>Now prioritize & implement the high value features first!
******[#black] <b><i><color #white><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_447.png Jira, Trello, User Story, Requirements & Backlog, Project Management & Client Management (Transparency with client)]]
****[#yellow] *<i><color #black><size:12>Surprise Features
*****[#yellow] *<i><color #black><size:12>Do **minimal architecture** like **Clean Architecture** so that you can "modify & maintain" the system
***[#green] <i><color #white><b><size:12>How to deal with that?
****[#yellow] <b><i><color #black><size:12>Prioritize on value & architecture impact
**[#lightblue] <i><color #black><size:12>Keep it simple

***[#green] <i><color #white><b><size:12>How?
****[#yellow]:*<i><color #black><size:12>Make it easy to understand
*<i><color #black><size:12>Make it easier to change
*<i><color #black><size:12>It has few moving parts in it
*<i><color #black><size:12>It Fails less but when fails, it fails gracefully;

****[#yellow] <i><color #black><size:12><b>Efficiency</b> is attained not by doing <b>tasks faster,\n<i><color #black><size:12>but by avoiding those tasks that <b>should not be done in the first place.
*****[#darkorange]:*<i><color #black><size:12>**[[docs/3-programming-languages/Venkat-Subramaniam/Unix-Philosophy.puml 15- Rule of optimization]]** unix philosophy; Moreover,
<i><color #black><size:13><b>E.g. don't do (Clean Architecture + [[docs/3-programming-languages/Venkat-Subramaniam/images/img_55.jpg DDD]]) for simple apps (system) as it's not applicable.
<i><color #black><size:13>Instead simple **three layer architecture** is enough. E.g. <b>[[docs/3-programming-languages/clean-architecture/archunit.adoc use ArchUnit]] to enforce the layers
*<i><color #black><size:13><b>[[docs/3-programming-languages/Venkat-Subramaniam/gif/DDD-and-subdomain-classification.html DDD & subdomain classification (Generic Subdomain, Core Subdomains, & Supporting Subdomains)]] this .html file open in browser
**<i><color #black><size:13><b>[[docs/3-programming-languages/Venkat-Subramaniam/images/DDD-and-questions.drawio.png Use DDD or not; answer the following  questions]];

**[#lightblue]:<i><color #black><size:22>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_249.png Refactor ]]
<i><color #black><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_466.png 1- Structure (generally reversible)]]
<i><color #black><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_466.png 2- Behavior (generally irreversible)]]
====
<i><color #black><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/how-to-approach-refactoring.puml How to approach refactoring "Venkat"]];
***[#green] <b><i><color #white><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_131.png 50% to 60% of the time you want to]]
****[#yellow] <i><color #black><size:12><b>Refactor:</b> others people code
***[#green] <b><i><color #white><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_131.png Other times you need to 've the courage to]]
****[#yellow] <i><color #black><size:12><b>Rewrite:</b> your own code
**[#lightblue] <i><color #black><size:12>Reversibility
***[#green] <b><i><color #white><size:12>Last responsible moment
****[#gold] <i><color #black><size:12>You either make the decision now or if you do not you begin to <b>procrastinate
****[#gold] <i><color #black><size:12><b>Two main reason: \n<i><color #black><size:12>**1-** You are smarter tomorrow than you are today\n<i><color #black><size:12>**2-** If I don't make the decision now, I can go faster focusing on other decisions that 've to \n<i><color #black><size:12>be done now. And you want to postponed things that gives you <b>focus.
****[#yellow] <i><color #black><size:12><b>E.g.</b> Databases (SQL or NoSQL) etc.
***[#yellow] <i><color #black><size:12>E.g. **"Rewrite"** java app in go-lang or C# or python, this is difficult, time consuming & hard to <b>reverse.
***[#yellow] <i><color #black><size:12>The more you are **couple to a decision** the harder it is to **reverse,** introduce **indirection** to increase <b>reversibility.
***[#a]:<i><color #black><size:12>Things which are irreversible (expensive to change) **postponed** them till the end of the <b>implementation.
*<b><i><color #black><size:12>Why don't we postpone?
**<b><i><color #green><size:12>Because we are afraid!
|<#red><b><i><color #white><size:12>[[docs/books/1-books-backlog/software-testing/automated-testing.puml If you want to "postpone" we need to 've good "automated testing". (TDD) click me]]|
<img:images/img_43.png{scale=.86}>
==<i><color #black><size:14><b>(TDD) gives you Control==
*<i><color #black><size:12><b>Statistical Control (SC):</b> is **TDD or unit testing** or <b><color:green>"Test Coverage"
**<i><color #black><size:12><b>"Testing"</b> numbs (freezes) us to loss of <b>reasoning (intellectual control)
*<i><color #black><size:12><b>Intellectual Control (IC):</b> is **simple design,** or <b>"Model Based Testing"</b> etc. but simply when <b>project
<i><color #black><size:12>"grows big" you start losing (intellectual control) on the <b>project;
****[#gold] <i><color #black><size:12><img:images/img_35.png{scale=0.7}>
****[#gold] *<i><color #black><size:12>**"Low code coverage"** means **bad code design** \n*<i><color #black><size:12>**"High code coverage"** does not <b>mean anything
****[#gold] <i><color #black><size:12>Machine Learning <b>"Model" "Testing"\n<i><color #black><size:12>is different than <b>(TDD)</b> that is:\n<i><color #black><size:12>**1-** Prediction\n<i><color #black><size:12>**2-** Pattern recognition\n<i><color #black><size:12>**3-** Optimization & decision making
****[#darkorange] <i><color #black><size:15><b>[[docs/3-programming-languages/Venkat-Subramaniam/Unix-Philosophy.puml 12- Rule of Repair & TDD:]] click me
***[#yellow] <i><color #black><size:12>Database decisions, libraries and frameworks decisions etc.
***[#darkorange] <i><color #black><size:12>**[[docs/1-Requirement-Engineering/MVP-PoC-and-case-study/Prototyping.puml Prototyping]]** is helpful\n*<i><color #black><size:12>**[[docs/3-programming-languages/Venkat-Subramaniam/Unix-Philosophy.puml 15- Rule of optimization]]** unix philosophy
***[#yellow] <i><color #black><size:12>**YAGNI principle** is not goona help you, if you 've very <b>poor (slow) feedback loop
**[#lightblue] <i><color #black><size:12>YAGNI
**[#lightblue] <i><color #black><size:20>What about <color #white>[[docs/3-programming-languages/Venkat-Subramaniam/Core-Software-design-principles-for-software-developers.puml "extensibility"?]]
***[#green] <i><color #white><b><size:12>Two things you need to \n<i><color #white><b><size:12>make software extensible.
****[#yellow] *<i><color #black><size:12><b>Domain Knowledge
****[#yellow] *<i><color #black><size:12><b>Knowledge of software design & concerns
***[#green] <i><color #white><b><size:12>Three Kinds of people \n<i><color #white><b><size:12>in an organization
****[#yellow] *<i><color #black><size:12><b>People with domain knowledge but no clue of Software design\n*<i><color #black><size:12>Too many in an organization
****[#yellow] *<i><color #black><size:12><b>People with no clue of domain knowledge but with knowledge the Software design\n*<i><color #black><size:12>Too many in an organization
****[#gold] *<i><color #black><size:18><b>People with domain knowledge & also knowledge of the Software design\n*<i><color #black><size:12>Very few in an organization
*****[#a] *<i><color #black><size:12><b>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_396.png Types of Software Engineers]]
**[#lightblue] <i><color #black><size:12>Parsimony\n*<i><color #black><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/Unix-Philosophy.puml 6- Rule of Parsimony]]
***[#green] <i><color #white><b><size:12>Absolute minimalism
****[#yellow] *<i><color #black><size:12><b>Write very few lines of code; Think does this really you need while writing code
**[#lightblue] <i><color #black><size:12>Triangulate
***[#green] <i><color #white><b><size:12>Develop the system in a light weight manner
**[#lightblue] <i><color #black><size:22>Postel's law
***[#green] <i><color #white><b><size:12>Communicating across systems
****[#gold] *<i><color #black><size:18>True in **microservices** world
****[#yellow] *<i><color #black><size:18><b>Postel's law says:</b> be very  <b>generous</b> about what you <b>receive\n<i><color #black><size:18>& be very <b>conservative</b> about what you <b>send\n<img:images/img_28.png{scale=1}>\n<i><color #black><size:12>So as long as I can **iterate** over your **collection** it does not what is the **type** of your <b>collection.\n<i><color #black><size:12>In other words, don't make your <b>interface brittle.
**[#lightblue] <i><color #black><size:22>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_64.png Reuse]] <size:12>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_160.png Modularity patterns]] & [[https://dzone.com/refcardz/patterns-modular-architecture website link]] \n<i><size:13>[[docs/3-programming-languages/Venkat-Subramaniam/Unix-Philosophy.puml 1- Rule of modularity]]\n<img:images/img_41.png{scale=0.7}>
***[#green] <i><color #white><b><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_137.jpg MVC vs MVP vs MVVP click me]]
***[#green] <i><color #white><b><size:12>Grady Booch Says:
****[#gold] *<i><color #black><size:18><b>First make the system "usable" then make the system <color #green>"reusable"
****[#yellow] *<i><color #black><size:18><b>To make a piece of the system/software "reusable" it has to be very<color #red> "generic"\n*<i><color #black><size:18><b>To make a piece of the system/software "usable"" it has to be very <color #brown>"specific"
****[#a] *<i><color #black><size:18><b>It's a tension between the two
***[#green] <i><color #white><b><size:12>In general:
****[#darkorange] <i><color #black><size:18>**[[docs/3-programming-languages/Venkat-Subramaniam/Core-Software-design-principles-for-software-developers.puml Logical design]]** (classes & packages) impacts <color #white><b>"extensibility"
****[#darkorange] <i><color #black><size:18>**[[docs/3-programming-languages/Venkat-Subramaniam/Core-Software-design-principles-for-software-developers.puml Physical design]]** (.jar) impacts <color #white><b>"re-usability & usability"
**[#lightblue]:<i><color #black><size:18>[[docs/3-programming-languages/Library-vs-Framework.puml Minimize libraries & frameworks]]
<i><color #black><size:12>I still use old libraries & frameworks. I use them because I know them already. Will I learn them today? Today
<i><color #black><size:12>I should learn things which are new & popular in market. <color #white>Venkat Subramaniam
==<i><color #black><size:14>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_266.png Minimizing frameworks. How?]] & [[docs/3-programming-languages/Venkat-Subramaniam/images/img_357.png Frameworks that you must marry?]]==
|<img:images/img_31.png{scale=0.84}>| <img:images/img_34.png>|
==<i><color #black><size:14>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_267.png Minimizing Libraries. How?]]==
|<img:images/img_56.jpg{scale=.65}>|<img:images/img_464.png{scale=.52}>|
<i><color #black><size:15>"interface" minimizes the "surface area" of "coupling code" & ease's replacing "library";
***[#yellow] <i><color #black><size:12>in the system, otherwise it is **"infatuation"** with the <b>"technology"
***[#darkorange] *<i><color #black><size:12>Don't **build** what you can **buy/download.** Don't **buy/download** what you don't <b>need! [[docs/3-programming-languages/Venkat-Subramaniam/images/img_428.png click me]]\n*<i><color #black><size:12>"To slaughter a goat for a single grain". You could **buy** the **needed grain** from <b>market!
***[#gold] <i><color #black><size:12>If we're going to 've a **delivery independent architecture**, we 've to start with \n<i><color #black><size:12><b>delivery independent <color:#brown>"use cases"
***[#darkorange] *<i><color #black><size:12>**"main ()"** function is at **outer most layer.** Why? Because it is near to **input/output** & prone to <b>changes. \n*<i><color #black><b><size:12>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_424.png click me]]
***[#a]:<i><color #black><size:12>There is nothing wrong with **[[docs/3-programming-languages/Venkat-Subramaniam/images/img_56.png outside-in or inside-out approach]]** so long as you **[[docs/3-programming-languages/Venkat-Subramaniam/Core-Software-design-principles-for-software-developers.puml decouple]]** your
<i><color #black><size:12>**[[docs/3-programming-languages/Venkat-Subramaniam/images/img_557.png business rules]]** from them.
*<i><color #black><size:12><b>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_557.png What are critical Business Rules?]], [[docs/3-programming-languages/Venkat-Subramaniam/images/img_559.png Business Rules & Coincidence Part-1]], [[docs/3-programming-languages/Venkat-Subramaniam/images/img_560.png Part-2]]
==<i><color #black><size:16>**[[docs/3-programming-languages/Venkat-Subramaniam/images/img_537.png Inside-out]], [[docs/3-programming-languages/Venkat-Subramaniam/images/img_555.png Bottom-up]], & [[docs/3-programming-languages/Venkat-Subramaniam/images/img_556.png BUFD]]** <color:yellow>(Low-level analysis & design)==
*<i><color #black><size:16>**Inside-out:** approach is (1st <u>**analyze & design entities & use cases layer**)
<i><color #black><b><size:16>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_558.png 1- Entities]], <size:12>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_555.png (Bottom-up design)]]
<i><color #brown><b><size:16>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_538.png 2- Use Cases]], <size:12>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_561.png (Top-down vs- Bottom-up?)]] & [[docs/2-uml/requirements-and-design-with-plantuml/1-use-cases-or-features/use-case-2-0-overview.puml use-case 2.0]] or [[docs/1-Requirement-Engineering/VU-course/Event-Storming-technique.adoc Event Storming]] or etc.
==<i><color #black><size:16>**[[docs/3-programming-languages/Venkat-Subramaniam/images/img_555.png Outside-in]], [[docs/3-programming-languages/Venkat-Subramaniam/images/img_555.png Top-down]]** <color:blue>(High-level analysis & design)==
*<i><color #black><size:16>**Outside-in:** approach (1st select right tools, integrations etc. for app development)
<i><color #green><b><size:15>4- Outer most layer <color #white>(Databases, Devices, External interfaces, Web, UI/UX etc.)
**<i><color #green><b><size:12>E.g. [[docs/books/1-books-backlog/DBMS/Designing-Data-Intensive-Applications.puml NFR technology constraints]], seldom "client" tells "explicitly" if not they still exist "implicitly"
**<i><color #green><b><size:12>E.g. [[docs/books/1-books-backlog/DBMS/Designing-Data-Intensive-Applications.puml SQL or NoSQL]]
**<i><color #green><b><size:12>E.g. CLI or [[docs/1-Requirement-Engineering/MVP-PoC-and-case-study/UI-UX.puml GUI (UI/UX)]]
**<i><color #green><b><size:12>E.g. [[docs/3-programming-languages/Venkat-Subramaniam/images/external-interfaces-or-APIs.png External Interfaces (APIs)]] or [[docs/1-Requirement-Engineering/APIs-design/types-of-APIs-Integration.puml Types of API integration]] or [[docs/1-Requirement-Engineering/APIs-design/Using-an-API.puml Using an API]] or [[docs/1-Requirement-Engineering/APIs-design/Designing-API.puml Designing API]]
**<i><color #green><b><size:12>E.g. [[docs/3-programming-languages/Venkat-Subramaniam/Designing-Reactive-Systems.puml Sync or Async]] (reactive system)
**<i><color #green><b><size:12>E.g. [[docs/3-programming-languages/Ola-Bini's-Language-Pyramid.puml Ola Bini's Language Pyramid]] or [[a Compiled vs Interpreted]] or [[a Structured vs FP vs OOP]]
**<i><color #green><b><size:12>E.g. [[docs/1-Requirement-Engineering/levels-of-distributed-system/Centralized-System.puml Centralized]] or [[docs/AI-ML-DL-Data-Science-and-BigData/data-science/designing-data-intensive-applications/Distributed-Systems.puml Distributed]]
**<i><color #green><b><size:12>E.g. [[docs/AI-ML-DL-Data-Science-and-BigData/data-science/data-engineering/Cloud-vs-On-Premise.puml On-premise or cloud or multi-cloud]] or [[docs/cloud-computing/Cloud-Native.puml cloud native]]
**<i><color #green><b><size:12>E.g. [[docs/books/1-books-backlog/operating-system/Linux-operating-system.puml O/S open source e.g. Linux]] or [[a proprietary e.g. Windows]]
**<i><color #green><b><size:12>E.g. [[a Brownfield]] (maintenance) or [[a Greenfield]] (new project)
**<i><color #green><b><size:12>E.g. [[docs/blockchain/Blockchain-System-Design.puml Blockchain (value exchange)]] or [[docs/blockchain/Blockchain-System-Design.puml Internet/Web (info. exchange)]] or Without internet etc.
==<i><color #black><size:16><b>Conclusion==
*<i><color #black><b><size:12>In reality a mix of both "inside-out & outside-in" is used.;
****[#yellow] <img:images/img_245.png{scale=.8}>
*****[#a]:*<i><color #black><b>Law of Attraction: Applies to both knowledge & materialistic desires
*<i><color #black><b>It can happen to both who do good deeds or sins at extreme level
*<i><color #black><b>Basic emotions involved in this motivator  are love, fear, & anger.
<i><color #white><b><size:12>Solution: Concept of God and Prayer
==<i><color #black><b><size:14>Knowledge Triangle & Hyperactive State of Mind==
*<i><color #black><b>Knowledge Triangle & Hyperactive State of Mind, imagination,
<i><color #black><b>intuition, & visualization.  <color #white>E.g. PTI was a state of mind. Group psychology!
*<i><color #black><b>It happens whenever you read, read, and do thinking about a concept or knowledge &
<i><color #black><b>you start getting a false sense of geneious that I know everything & you start thinking,
<i><color #black><b>acting, & behave like I had reached at bottom of this knowledge triangle & I've acknowledged
<i><color #black><b>everything. But this is not reality.
*<i><color #black><b>And when this hyperactive state of mind becomes weaker resultantly this acquired imagination
<i><color #black><b>starts diminishing.
*<i><color #black><b>Hyperactive active state of mind gets weaker when you stop reading & think about this particular
<i><color #black><b>knowledge or concept, idea, or thought which are actually intangible & are abstract. But when you
<i><color #black><b>start reading & thinking about these a lot & hence cross the threshold then these intangible &
<i><color #black><b>abstract things become concrete. But they exist inside your inner world (mind) but if you still
<i><color #black><b>does not stop here then you may start seeing & observing these in outer worl (physical world, real)
<i><color #black><b>life). But actually this is self constructed illusion.;
***[#gold] <b><i>Resume Driven Development
****[#yellow]:<i><b><size:12>Separate the things you've "learnt" from things you 've "used in production."
*<i><color #black><b><size:12>If the list of things you've used in production is long then we can't talk because you will complicate my system
<i><color #black><b><size:12>\t unnecessarily & I will not be able to release my "product".
*<i><color #black><b><size:12>If the list of things you've used in production is small than the things you've learnt over the years then we can talk;
**[#lightblue] <i><color #black><size:12>Summary

@endmindmap
