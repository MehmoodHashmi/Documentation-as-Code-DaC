@startmindmap
title =<i><b><u>Towards an Evolutionary Architecture
* ===<i><b>[[docs/3-programming-languages/Venkat-Subramaniam/Core-Software-design-principles-for-software-developers.puml Core Software design principles for software developers by Venkat Subramaniam]]
!theme hacker

*[#darkblue] <i>Towards an \n<i>Evolutionary Architecture
**[#lightblue] <i><color #black><size:14>What's architecture?
***[#green] <i><color #white><b><size:14>Definition
****[#yellow] <i><color #black><size:14>Shape of the major structure of a system or topology. architecture is a view of a system.
****[#yellow] <i><color #black><size:14>Martin fowler article, who needs an architect.
*****[#gold] <i><color #black><size:14>Shared understainding between the senior team members of a system.
***[#green] <b><i><color #white><size:14>Why evolutionary architecture?
****[#darkorange] <b><i><color #black><size:14>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_27.png Clean Architecture]] click me
*****[#yellow] <i><color #black><size:18>--BUFD-- is waterfall
*****[#yellow] <i><color #black><size:18>Agile (No Design) is disaster
*****[#yellow] <i><color #black><size:18>EUFD <&check>
****[#darkorange] <b><i><color #black><size:14>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_26.png Onion Architecture]] click me
****[#darkorange] <i><color #black><size:14><b>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_26.png Hexagonal Architecture + DDD]] click me
***[#green] <b><i><color #white><size:14>In Software Development we often say:
****[#yellow] <i><color #black><size:18>Capture requirements
****[#yellow] <i><color #black><size:18>Gather requirements
****[#yellow] <i><color #black><size:18>Observer effect
****[#gold] *<i><color #black><size:14>If you want to build what your customers wanted, you will <b>fail.\n*<i><color #black><size:14>You need to build what your customers still want.
****[#yellow] <i><color #black><size:18>Build working software.
*****[#gold] <i><color #black><size:14>Half of the total programmers in the world can do it
*****[#gold] <i><color #black><size:14>But I want to build relevant working software\n*<i><color #black><size:14>Requires more effort
****[#gold] *<i><color #black><size:14>PowerPoint Architect
****[#darkorange] *<i><color #black><size:15><b>No one cares if you write good code
*****[#gold] <i><color #black><size:22><b>Does this code saves or makes money?
**[#lightblue] <i><color #black><size:14>The risk of not evolving
***[#green] <b><i><color #white><size:14>Relevance
****[#gold]:*<i><color #black><size:14>If not evolved may become obsolete & irrelevant.
<i><color #black><size:14>**1-** Team is held hosted by the architects, architect says you will develop it because we architected it.
<i><color #black><size:14>**2-** System does one thing & architecture diagrams on the walls does completely different things, they
<i><color #black><size:14>deliver a "working system" which is not in **sync** with its <b>architecture;
***[#green] <b><i><color #white><size:14>Governance
****[#gold] *<i><color #black><size:14>**Architecture committee,** slows down the process & "initial architecture" draft becomes useless.
**[#lightblue] <i><color #black><size:14>The risk of  evolving
***[#green] <b><i><color #white><size:14>What if we can't support a feature?
****[#yellow] *<i><color #black><size:14><b>Planned Features
*****[#yellow] *<i><color #black><size:14>Things you know, you will work on, in the beginning of the project you had project backlog. \n<i><color #black><size:14>A list of requirements given to you.
*****[#yellow] *<i><color #black><size:14>Find the following for each <b>user story:\n#<i><color #black><size:14>Business value\n#<i><color #black><size:14>Architecture Impact\n*<i><color #black><size:14>Now prioritize & implement the high value features first!
****[#yellow] *<i><color #black><size:14>Surprise Features
*****[#yellow] *<i><color #black><size:14>Do **minimal architecture** like **Clean Architecture** so that you can "modify & maintain" the system
***[#green] <i><color #white><b><size:14>How to deal with that?
****[#yellow] <b><i><color #black><size:14>Prioritize on value & architecture impact
**[#lightblue] <i><color #black><size:14>Keep it simple
***[#green] <i><color #white><b><size:14>How?
****[#yellow] <i><color #black><size:14>Make it easy to understand
****[#yellow] <i><color #black><size:14>Make it easier to change
****[#yellow] <i><color #black><size:14>It has few moving parts in it
****[#yellow] <i><color #black><size:14>It Fails less but when fails, it fails gracefully
****[#yellow] <i><color #black><size:14><b>Efficiency</b> is attained not by doing <b>tasks faster,\n<i><color #black><size:14>but by avoiding those tasks that <b>should not be done in the first place.
*****[#darkorange] <i><color #black><size:14><b>E.g. don't do (Clean Architecture + DDD) for simple apps (system).\n<i><color #black><size:14>Instead simple **three layer architecture** is enough.
**[#lightblue] <i><color #black><size:14>Refactor
***[#green] <b><i><color #white><size:14>50% to 60% of the time you want to
****[#yellow] <i><color #black><size:14><b>Refactor:</b> others people code
***[#green] <b><i><color #white><size:14>Other times you need to 've the courage to
****[#yellow] <i><color #black><size:14><b>Rewrite:</b> your own code
**[#lightblue] <i><color #black><size:14>Reversibility
***[#green] <b><i><color #white><size:14>Last responsible moment
****[#gold] <i><color #black><size:14>You either make the decision now or if you do not you begin to <b>procrastinate
****[#gold] <i><color #black><size:14><b>Two main reason: \n#<i><color #black><size:14>You are smarter tomorrow than you are today\n#<i><color #black><size:14>If I don't make the decision now, I can go faster focusing on other decisions that 've to \n<i><color #black><size:14>be done now. And you want to postponed things that gives you <b>focus.
****[#yellow] <i><color #black><size:14><b>E.g.</b> Databases (SQL or NoSQL) etc.
***[#yellow] <i><color #black><size:14>Like **"Rewrite"** java app in go-lang or C# or python, this is difficult, time consuming & hard to <b>reverse.
***[#yellow] <i><color #black><size:14>The more you are couple to a decision the harder it is to reverse, introduce **indirection** to increase <b>reversibility.
***[#yellow] <i><color #black><size:14>Things which are irreversible (expensive to change) **postponed** them till the end of the <b>implementation.\n*<b><i><color #black><size:14>Why don't we postpone?\n**<b><i><color #green><size:14>Because we are afraid!\n*<b><i><color #black><size:14>If you want to "postpone" we need to 've good "automated testing". (TDD)\n<img:images/img_43.png>
****[#gold] <i><color #black><size:14><img:images/img_35.png>
***[#yellow] <i><color #black><size:14>Database decisions, libraries and frameworks decisions etc.
***[#yellow] <i><color #black><size:14>**Prototyping** is helpful
***[#yellow] <i><color #black><size:14>**YAGNI principle** is not goona help you, if you 've very <b>poor (slow) feedback loop
**[#lightblue] <i><color #black><size:14>YAGNI
**[#lightblue] <i><color #black><size:20>What about <color #white>"extensibility"?
***[#green] <i><color #white><b><size:14>Two things you need to \n<i><color #white><b><size:14>make software extensible.
****[#yellow] *<i><color #black><size:14><b>Domain Knowledge
****[#yellow] *<i><color #black><size:14><b>Knowledge of software design & concerns
***[#green] <i><color #white><b><size:14>Three Kinds of people \n<i><color #white><b><size:14>in an organization
****[#yellow] *<i><color #black><size:14><b>People with domain knowledge but no clue of Software design\n*<i><color #black><size:14>Too many in an organization
****[#yellow] *<i><color #black><size:14><b>People with no clue of domain knowledge but with knowledge the Software design\n*<i><color #black><size:14>Too many in an organization
****[#gold] *<i><color #black><size:18><b>People with domain knowledge & also knowledge of the Software design\n*<i><color #black><size:14>Very few in an organization
**[#lightblue] <i><color #black><size:14>Parsimony
***[#green] <i><color #white><b><size:14>Absolute minimalism
****[#yellow] *<i><color #black><size:14><b>Write very few lines of code; Think does this really you need while writing code
**[#lightblue] <i><color #black><size:14>Triangulate
***[#green] <i><color #white><b><size:14>Develop the system in a light weight manner
**[#lightblue] <i><color #black><size:22>Postel's law
***[#green] <i><color #white><b><size:14>Communicating across systems
****[#gold] *<i><color #black><size:18>True in **microservices** world
****[#yellow] *<i><color #black><size:18><b>Postel's law says:</b> be very  <b>generous</b> about what you <b>receive\n<i><color #black><size:18>& be very <b>conservative</b> about what you <b>send\n<img:images/img_28.png>\n<i><color #black><size:14>So as long as I can **iterate** over your **collection** it does not what is the **type** of your <b>collection.\n<i><color #black><size:14>In other words, don't make your <b>interface brittle.
**[#lightblue] <i><color #black><size:22>Reuse <size:14>\t\t\t(Modularity patterns)\n<img:images/img_41.png>
***[#green] <i><color #white><b><size:14>Grady Booch Says:
****[#gold] *<i><color #black><size:18><b>First make the system "usable" then make the system <color #green>"reusable"
****[#yellow] *<i><color #black><size:18><b>To make a piece of the system/software "reusable" it has to be very<color #red> "generic"
****[#yellow] *<i><color #black><size:18><b>To make a piece of the system/software "usable"" it has to be very <color #brown>"specific"
****[#a] *<i><color #black><size:18><b>It's a tension between the two
***[#green] <i><color #white><b><size:14>In general:
****[#darkorange] <i><color #black><size:18>**Logical design** (classes & packages) impacts <color #white><b>"extensibility"
****[#darkorange] <i><color #black><size:18>**Physical design** (.jar) impacts <color #white><b>"re-usability & usability"
**[#lightblue] <i><color #black><size:18>Minimize libraries & frameworks\n<img:images/img_31.png><img:images/img_34.png>
***[#yellow] <i><color #black><size:14>in the system, otherwise it is "infatuation" with the "technology"
***[#yellow] <i><color #black><size:14>Don't **build** what you can **buy/download.** Don't **buy/download** what you don't <b>need!
***[#a]:<i><color #black><size:14>There is nothing wrong with **outside-in or inside-out approach** so long as you
<i><color #black><size:14>**decouple** your **business rules** from them.
==<i><color #black><size:16>**Inside-out** <color:yellow>(Low-level analysis & design)==
*<i><color #black><size:16>**Inside-out:** approach is (1st <u>**analyze & design entities & use cases layer**)
<i><color #yellow><b><size:16>1- Entities
<i><color #brown><b><size:16>2- Use Cases
==<i><color #black><size:16>**Outside-in** <color:blue>(High-level analysis & design)==
*<i><color #black><size:16>**Outside-in:** approach (1st select right tools for app & integration b/w components)
<i><color #green><b><size:15>4- Outer most layer (Databases, Devices, External interfaces, Web, UI/UX etc.)
**<i><color #green><b><size:12>E.g. [[docs/books/1-books-backlog/DBMS/Designing-Data-Intensive-Applications.puml SQL or NoSQL]]
**<i><color #green><b><size:12>E.g. CLI or [[docs/1-Requirement-Engineering/MVP-PoC-and-case-study/UI-UX.puml GUI (UI/UX)]]
**<i><color #green><b><size:12>E.g. [[docs/3-programming-languages/Venkat-Subramaniam/images/external-interfaces-or-APIs.png External Interfaces (APIs)]] or [[docs/1-Requirement-Engineering/APIs-design/types-of-APIs-Integration.puml Types of API integration]] or [[docs/1-Requirement-Engineering/APIs-design/Using-an-API.puml Using an API]] or [[docs/1-Requirement-Engineering/APIs-design/Designing-API.puml Designing API]]
**<i><color #green><b><size:12>E.g. [[docs/3-programming-languages/Venkat-Subramaniam/Designing-Reactive-Systems.puml Sync or Async]] (reactive system)
**<i><color #green><b><size:12>E.g. [[docs/1-Requirement-Engineering/levels-of-distributed-system/Centralized-System.puml Centralized]] or [[docs/AI-ML-DL-Data-Science-and-BigData/data-science/designing-data-intensive-applications/Distributed-Systems.puml Distributed]]
**<i><color #green><b><size:12>E.g. [[docs/AI-ML-DL-Data-Science-and-BigData/data-science/data-engineering/Cloud-vs-On-Premise.puml On-premise or cloud or multi-cloud]] or [[docs/cloud-computing/Cloud-Native.puml cloud native]]
**<i><color #green><b><size:12>E.g. [[docs/books/1-books-backlog/operating-system/Linux-operating-system.puml O/S open source e.g. Linux]] or proprietary e.g. Windows
**<i><color #green><b><size:12>E.g. [[a Brownfield]] (maintenance) or [[a Greenfield]] (new project)
**<i><color #green><b><size:12>E.g. [[docs/blockchain/Blockchain-System-Design.puml Blockchain (value exchange)]] or [[docs/blockchain/Blockchain-System-Design.puml Internet/Web (info. exchange)]] or Without internet etc.
==<i><color #black><size:16><b>Conclusion==
*<i><color #black><b><size:14>In reality a mix of both "inside-out & outside-in" is used.;
**[#lightblue] <i><color #black><size:14>Summary

@endmindmap
