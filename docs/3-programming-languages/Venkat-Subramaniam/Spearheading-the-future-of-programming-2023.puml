@startmindmap
title =<i><b><u>Spearheading the future of programming \nDr.Venkat Subramaniam -  2023
!theme hacker

*[#darkblue] <i>Spearheading the \n<i>future of programming
**[#lightblue] <i><color #blac><size:14>Definition
***[#green]:<i><color #white><size:14>I program in about 15 different languages what I mean by that is I'm not good in any one of them but I love programming &  I started programming because of
<i><color #white><size:14>the **love I had for Math, physics and Science** in general but <b>"35 years later I'm still a programmer"</b> because of the <b>art and programming that I see.;

***[#green]:<i><color #white><size:14>I will talk what do I want to see in programming languages as we move forward over the years as I programmed in multiple languages.
<i><color #white><size:14>I've kind of enjoyed some languages more than others;
***[#green] <i><color #white><size:14><b>Where things are today and where things are heading

**[#lightblue] <i><color #blac><size:14>Characteristics
***[#green] <b><i><color #white><size:14>"Things change really fast in our field"
****[#yellow] <i><color #black><size:14>Sure, true to some extent
***[#green] <b><i><color #white><size:14>How are we Programming in new Century?
****[#yellow] <i><color #black><size:14>Still imperative programming e.g. <b> for (int i =0; i < prices.size() -1; i ++) {}
*****[#yellow] <i><color #black><size:14>Verbose code
***[#green] <b><i><color #white><size:14>Challenge
****[#yellow] <i><color #black><size:14>Learning new <b>"programming language"</b> is easy
****[#yellow] <i><color #black><size:14>Learning new <b>"programming Paradigm"</b> is hard <b>(takes more effort)
***[#green] <b><i><color #white><size:22>Paradigm Shift
****[#yellow] <i><color #black><size:14><b>1st paradigm shift:</b> Procedural programming or <b>"algorithmic decomposition" of code (modules)
*****[#gold] *<i><color #black><size:14><b>Time & Space complexity analysis</b>\n*<i><color #black><size:15><b>[[docs/3-programming-languages/Venkat-Subramaniam/Goal-of-the-data-structures-is-no-incidental-data-structures.puml Data-Structure]] + [[docs/books/1-books-backlog/data-structure-and-algorithm/Algorithms-Four-Principles-of-optimality.puml Algorithm]] = <color #red>Program</b>\n*<i><color #black><size:14><b>Good for <u>"decomposition"</b>\n*<i><color #black><size:14><b>"Pointer" is <u>"in-direction"</b>\n*<i><color #black><size:14><b>"Diagramming:" using <u>"flowchart"</b>
****[#yellow] <i><color #black><size:14><b>2nd paradigm shift:</b> Object Oriented Programming or <b>"object decomposition" of code (modules)
*****[#yellow] <i><color #black><size:14><b>OOA&D</b>\n*<i><color #black><size:14><b>Objects + Messages = <color #red>Program\n*<i><color #black><size:14><b>Good for "modeling"</b>\n*<i><color #black><size:14><b>"Runtime-Polymorphisim" is <u>"in-direction"</b>\n*<i><color #black><size:14><b>"Diagramming:" using <u>"UML"</b>
******[#gold] <i><color #black><size:14><img:images/img_33.png>
****[#yellow] <i><color #black><size:14><b>3rd paradigm shift:</b> Distributed Object Computing or Common Object Request Broker Architecture <b>(CORBA)
*****[#yellow] <i><color #black><size:14>Remote computing
****[#darkorange] <i><color #black><size:15><b>4rth paradigm shift: [[docs/3-programming-languages/Venkat-Subramaniam/Asynchronous-Programming-in-Java-Options-to-Choose-from.puml Asynchronous Programming]]\n*<i><color #black><size:14><b>[[docs/3-programming-languages/Venkat-Subramaniam/gif/synchronous-vs-asynchronous.adoc Asynchronous is non-blocking]] click gif\n*<i><color #black><size:14><b>[[docs/3-programming-languages/Venkat-Subramaniam/gif/Multi-threading-vs-Multi-processing-programming.adoc Multi-threading vs Multi-processing programming ]]
*****[#yellow]:<i><color #black><size:14><b>It took me more time to understand it. Why? Because</b>
* <color #black><size:14><i>I was not satisfied writing another <b>"callback"</b> & go home
* <color #black><size:14><i>I wanted to understand the following:
** <color #black><size:14><i> <b>How these "callback" behave</b>
** <color #black><size:14><i> <b>How these "callback" work</b>
** <color #black><size:14><i> <b>And reason these "callback" work</b>;
******[#gold]:<i><color #black><size:14><b>I Can relate to this from FSc:
*<i><color #black><size:14>Construction <b>(at high level)
*<i><color #black><size:14>Working/setup
*<i><color #black><size:14>Reason its working;

****[#darkorange] <i><color #black><size:15><b>5th paradigm shift: [[docs/3-programming-languages/Venkat-Subramaniam/Imperative-vs-Functional-Which-one-to-Choose.puml Functional Programming]]
*****[#yellow]:*<i><color #green><size:14><b>Lambda (->) is indirection
*<i><color #green><size:14><b> (function-1)(function-2) = <color #red>Program
**<i><color #green><size:14><b>"FP" is good for "reasoning"
*<i><color #black><size:14><b>"Diagramming:" using <u>"Category theory",</u> it is equivalent of "UML"</b>
<i><color #black><size:14>People said it's very easy but it was not. **Why?** Because it was really hard
<i><color #black><size:14>to think a different way than what I'm used to thinking in <b>imperative style
<img:images/img_29.png>;
******[#darkorange]:<i><color #black><size:32><b>[[docs/3-programming-languages/Venkat-Subramaniam/Streams.puml What is Stream?]] click me
*<i><color #black><size:14>**Stream** is an **abstraction,** it is not a <b>data structure or collection
*<i><color #black><size:14>It is <b>non-mutating
*<i><color #black><size:14>A view of how **data** is <b>transformed
*<i><color #black><size:14><b>Pipeline schema <color #white>(ETL vs ELT)
====
*<i><color #black><size:14><b>Stream employs function composition
*<i><color #black><size:14><b>"Stateless" behavior
*<i><color #black><size:14><b>"pure" functions
*<i><color #black><size:14><b>"Specialized" functions</b> (filter, Map)  **rides** the <b>stream
**<i><color #black><size:14><b>Reduce<b> function using reduce function helps</b> you land on the
<i><color #black><size:14>**concrete** type from <b>abstract (stream);
****[#darkorange] <i><color #black><size:15><b>6th paradigm shift: [[docs/3-programming-languages/Venkat-Subramaniam/Designing-Reactive-Systems.puml Reactive Programming or functional programming++]]
*****[#yellow] <i><color #black><size:14>Is an <b>abstraction</b> on top of functional programming
****[#darkorange] <i><color #black><size:15><b>7th paradigm shift: [[docs/3-programming-languages/Venkat-Subramaniam/Logic-Programming.puml Logic Programming]]
*****[#yellow] <i><color #black><size:14><b>Facts + Rules = <color #red>Program</b> \n*<i><color #black><size:14><b>Good for "Searching"
******[#a] <i><color #black><size:14><b>E.g. "languages" like Prolog, & Datalog
****[#darkorange] <i><color #black><size:22><b>8th paradigm shift:</b> <b>[[docs/AI-ML-DL-Data-Science-and-BigData/data-science/statistics/professor-leonard-statistics-notes/descriptive-(or-EDA)-statistics/4-machine-learning.puml Machine learning]] click\n<img:images/img_7.png>
*****[#darkorange] <i><color #black><size:22><b>[[docs/books/selfanalysis/anatomy-of-knowledge.puml Anatomy of knowledge]] click me\n<img:images/img_8.png>
******[#darkorange] <i><color #black><size:14><b>[[docs/AI-ML-DL-Data-Science-and-BigData/big-data/big-data.puml Data]] + [[docs/AI-ML-DL-Data-Science-and-BigData/machine-learning-ML/Modern-Machine-Learning.puml Algorithm]] = [[docs/AI-ML-DL-Data-Science-and-BigData/machine-learning-ML/machine-learning-basic-terminology.puml Model]] \n*<i><color #black><size:14><b>"ML" Good for "Pattern recognition", "Predictions" & \n<i><color #black><size:14><b>"Optimization & decision making"
******[#yellow] <i><color #black><size:22><b>Data-set\n<img:images/img_6.png>
***[#green] <b><i><color #white><size:14>People ask me which programming language I should learn
****[#yellow] <i><color #black><size:14>I always tell don't pick a **language** to learn instead pick a **programming paradigm** to learn
****[#yellow] <i><color #black><size:14>Because when you learn a <b>different paradigm,</b> you learn a <b>different way of thinking
****[#yellow] <i><color #black><size:14>Because when you know <b>Java</b> & then you learn <b>C#,</b> it does not count, your total count is still one
****[#yellow]:<i><color #black><size:14>Pickup something that will hurt you, make your cry, beg for mercy only then you are learning something interesting.
<i><color #black><size:14>It changes the way you **"think"** & will change the way you **"program and design"** as well.;

***[#green] <b><i><color #white><size:14>Somethings are fundamental & hard to change
****[#yellow] <i><color #black><size:14>E.g. Turing completeness
*****[#yellow]:<i><color #black><size:14>Why would you want to use a "programming language" that is not "turing complete"?

<i><color #black><size:14>That to me is a pretty low bar in a lot of ways because Turing completeness often
<i><color #black><size:14>doesn't talk about
*<i><color #black><size:14><b>Efficiency of programming
*<i><color #black><size:14><b>Speed at which the code can run
*<i><color #black><size:14><b>Elegance of the code
<i><color #black><size:14>none of it really addresses in that regard. So we want to think about <b>"turing complete"
<i><color #black><size:14>but we have to go beyond that in a lot of ways when looking at <b>"languages";
****[#yellow] <i><color #black><size:14>E.g. Von Newman bottleneck
*****[#yellow]:<i><color #black><size:14>In terms of moving:
*<i><color #black><size:14><b>objects around
*<i><color #black><size:14><b>data around memory
<i><color #black><size:14>This often becomes a challenge especially when we do <b><u>distributed computing
<i><color #black><size:14>and when we trying to really do all these <b>architectures</b> that we are trying to
<i><color #black><size:14>implement these days that becomes a challenge;
*****[#yellow] <i><color #black><size:14><b>Grady Booch said: \n<i><color #black><size:14>"There are some physics limitations" that is I can't make data travel faster than the speed of light
*****[#yellow] <i><color #black><size:14><b>Hardware limitations:</b> CPUs, GPUs, TPUs, & so on. & **Heat** produced by these <b>hardware

**[#lightblue] <i><color #blac><size:14>When was OOP introduced?
***[#green] <b><i><color #white><size:14>During the 1990 OOP became popular
****[#yellow] <i><color #black><size:14>OOP was introduced in 1967.
****[#yellow] <i><color #black><size:14>It took 23-years for OOP to become mainstream. Is this fast? When people tell me things are changing very fast. <b>Really!
****[#yellow] <i><color #black><size:14>Things don't change as fast it actually changes. e.g. it took 23-years for OOP to become mainstream
****[#yellow] <i><color #black><size:14>What is 23-years? It took 23-years for OOP to become mature

**[#lightblue] <i><color #blac><size:14>What about "functional programming"?
***[#green] <b><i><color #white><size:14>Most mainstream programming languages support "FP"
****[#yellow] <i><color #black><size:14><b>Most "languages" are "hybrid" today
***[#green] <b><i><color #white><size:14>When was "lambda calculus" created?
****[#yellow] <i><color #black><size:14>1930s it was created
***[#green] <b><i><color #white><size:14>Why does it take so long for adoption?
****[#yellow] <i><color #black><size:14>We take change in bit size
****[#yellow] <i><color #black><size:14>Habits are hard to change, it takes a new generation
****[#yellow] <i><color #black><size:14>We are poised (prepare) for a few big changes
****[#yellow] <i><color #black><size:14>It started between 2003-2006
*****[#yellow] <i><color #black><size:14>Hardware changed <b>(single core to multiple core machines)
*****[#yellow] <i><color #black><size:14>Business world decided to change
*****[#a] <i><color #black><size:22><b>Other factors:</b> Modern demands, <b>[[docs/cloud-computing/Cloud-Native.puml Cloud,]] [[docs/AI-ML-DL-Data-Science-and-BigData/big-data/big-data.puml Big Data]], IoT, [[docs/AI-ML-DL-Data-Science-and-BigData/data-science/statistics/professor-leonard-statistics-notes/descriptive-(or-EDA)-statistics/4-machine-learning.puml ML]], Microservices
****[#yellow] <i><color #black><size:22><b>Some answers:</b>
*****[#darkorange] <b><i><color #black><size:18>[[docs/books/1-books-backlog/DBMS/Designing-Data-Intensive-Applications.puml NoSQL,]] [[docs/AI-ML-DL-Data-Science-and-BigData/Apache-Big-Data-Ecosystem/MapReduce.puml MapReduce,]] [[docs/3-programming-languages/Venkat-Subramaniam/Designing-Reactive-Systems.puml Reactive]]
**[#lightblue] <i>Web
***[#green] <b><i><color #white><size:14>How do we build web-apps?
****[#yellow] <i><color #black><size:14>"Stateless" <b>(Request-Response)
*****[#yellow] <i><color #black><size:14>Poor separation of concern
***[#green] <b><i><color #white><size:14>How do we build moderen web-apps?
****[#yellow] <i><color #black><size:14>"Continuations" <b>(Request-Response)
*****[#yellow] <i><color #black><size:14>Save execution state & return to that point later in time
****[#darkorange] <b><i><color #black><size:14>[[docs/3-programming-languages/Venkat-Subramaniam/Imperative-vs-Functional-Which-one-to-Choose.puml "Languages" should make simple things simpler, hard things manageable]]
****[#yellow] <i><color #black><size:15>Languages must promote <b>higher-level of abstraction, compos-ability, & declarative style
****[#yellow] <i><color #black><size:15><b>Expressive Languages</b> (intuitive to use)
*****[#yellow] <i><color #black><size:15><b>"Expressive code"</b> often leads to better design & extensibility
*****[#yellow] <i><color #black><size:15>Efficiency
******[#yellow] <i><color #black><size:15>It is cute. <b>Cuteness doesn't last very long!\n<img:images/img_9.png>
******[#yellow] <i><color #black><size:15>It is cute. <b>Cuteness + Efficiency is highly critical!\n<img:images/img_10.png>
******[#gold]:*<size:14><color #black><i>**Functional Programming:** relies on "lazy evaluation" for <b>"efficiency"
*<size:14><color #black><i>**"lazy evaluation"** relies on **"purity of functions"** (immutability) for <b>"correctness"
*<size:14><color #black><i>We need make sure **"lambda" (->)** are <b>"pure"

**<size:14><color #black><i>Pure functions do not have side-effects. They are <b>idempotent.
**<size:14><color #black><i>**Idempotent:** For the same input function always produces same output

<size:14><color #black><i><u><b>Rules of Purity </b>(rule 1 is necessary but not sufficient)
#<size:14><color #black><i> The function does not mutate or change anything that is visible from the outside
#<size:14><color #black><i>The function does not depend on anything from outside that may/possibly change;
*****[#yellow] <i><color #black><size:14><b>Hybrid "languages"</b> can't enforce **(immutability),** so it is on us to take care of that
****[#darkorange] <i><color #black><size:18><b>Asynchronous Programming\n*<i><color #black><size:14><b>[[docs/3-programming-languages/Venkat-Subramaniam/gif/synchronous-vs-asynchronous.adoc Asynchronous is non-blocking]] click gif\n*<i><color #black><size:14><b>[[docs/3-programming-languages/Venkat-Subramaniam/gif/Multi-threading-vs-Multi-processing-programming.adoc Multi-threading vs Multi-processing programming ]]
**[#lightblue] <i><color #blac><size:14>What we should do?
***[#green] <b><i><color #white><size:14>Studies suggest multilingual exposure boosts children's communication skills
***[#green] <b><i><color #white><size:14>The amount of time we need to learn a new concept is inversely proportional to the diverse ideas we 've been exposed to.
***[#green] <b><i><color #white><size:14>So learning different paradigms exposes to different ideas, learning different paradigms exposes to different line of thinking
***[#green] <b><i><color #white><size:11>So the more we think differently the faster we learn to think differently. The less we are exposed to different things the harder it is for us to change when the language we are using changes already
***[#green] <b><i><color #white><size:17>Learn different languages, not to use them all... But to able to adapt to change quickly & easily as the languages we use evolve
@endmindmap
