.top-6-cloud-messaging-patterns
image::top-6-cloud-messaging-patterns.webp[width = 650]

Top 6 Cloud Messaging Patterns.

How do services communicate with each other? The diagram below shows 6 cloud messaging patterns.

ðŸ”¹ Asynchronous Request-Reply
This pattern aims at providing determinism for long-running backend tasks. It decouples backend processing from frontend clients.

In the diagram below, the client makes a synchronous call to the API, triggering a long-running operation on the backend. The API returns an HTTP 202 (Accepted) status code, acknowledging that the request has been received for processing. Once the work is complete, the status endpoint can either return a resource that indicates completion, or redirect to another resource URL (HTTP 302).

ðŸ”¹ Publisher-Subscriber
This pattern targets decoupling senders from consumers, and avoiding blocking the sender to wait for a response.

This increases scalability and improves responsiveness of the sender, allowing for deferred or scheduled processing. It enables simpler integration between systems using different platforms, programming languages, or communication protocols, as well as between on-premises systems and applications running in the cloud.

ðŸ”¹ Claim Check
This pattern solves the transmision of large messages. It stores the whole message payload into a database and transmits only the reference to the message, which will be used later to retrieve the payload from the database.

ðŸ”¹ Priority Queue
This pattern prioritizes requests sent to services so that requests with a higher priority are received and processed more quickly than those with a lower priority.

ðŸ”¹ Saga
Saga is used to manage data consistency across multiple services in distributed systems, especially in microservices architectures where each service manages its own database.

The saga pattern addresses the challenge of maintaining data consistency without relying on distributed transactions, which are difficult to scale and can negatively impact system performance.

ðŸ”¹ Competing Consumers
This pattern enables multiple concurrent consumers to process messages received on the same messaging channel. There is no need to configure complex coordination between the consumers. However, this pattern cannot guarantee message ordering.