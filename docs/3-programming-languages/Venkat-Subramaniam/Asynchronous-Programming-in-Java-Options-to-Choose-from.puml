@startmindmap
title =<i><b><u>Asynchronous Programming in Java: Options to Choose from \nDr.Venkat Subramaniam -  2023\n His PhD is in parallelisim
* <i><b>[[https://www.youtube.com/watch?v=1zSF1259s6w&t=4778s&ab_channel=Devoxx Asynchronous Programming in Java: Options to Choose from By Venkat Subramaniam]]
!theme hacker

*[#darkblue] <i>Asynchronous Programming in Java:\n<i>Options to Choose from
**[#lightblue] <i><color #blac><size:14>Introduction
***[#green]:<i><color #white><size:14>Java has had parallel and concurrent programming facilities from the start. In recent years the business has needed as much, if not more,asynchronous
<i><color #white><size:14>capabilities, with <b>webservices and microservices.</b> We will discuss the various options available, such as completable futures, reactive steams, & the newer
<i><color #white><size:14><b>virtual threads</b> and discuss which options are better suited and why.;

**[#lightblue] <i><color #blac><size:14>Threading
***[#green] <i><color #white><size:14><b>[[docs/3-programming-languages/Venkat-Subramaniam/gif/Multi-threading-vs-Multi-processing-programming.adoc Parallel vs Concurrent]] click gif
****[#yellow] <i><color #black><size:14>Think about execution. In what sequence code gets executed?
****[#yellow] <i><color #black><size:14><b>Parallel:</b> I can walk & talk in parallel\n<img:gif/img_2.png>
****[#yellow] <i><color #black><size:14><b>Concurrent:</b> I can either drink or talk but not both simultaneously\n<img:gif/img_3.png>
****[#yellow] <i><color #black><size:14><b>Resources (CPU/GPU/TPU cores) & RAM:</b> usually put restrictions/limitations on which one we can use
****[#a] <i><color #black><size:14><b>Java-1.0:</b> had <b>[[docs/3-programming-languages/Venkat-Subramaniam/Threads.puml Threads]]</b> (light weight), but sooner realized its drawback
****[#yellow] <i><color #black><size:14><b>Java-5.0:</b> had <b>Executors.</b> Don't keep creating threads all over the place its bad idea. Instead create pools of threads & schedule tasks on the pool\n*<i><color #black><size:18>In both life & programming we solve a set of problems only to realize we have now created a new set of problems\n*<i><color #black><size:18>Executors ended up into pool induced deadlocks. It was annoying!
****[#yellow] <i><color #black><size:14><b>Java-7.0:</b> had <b>ForkJoin API</b> was introduced pool introduced deadlocks.
****[#yellow] <i><color #black><size:14><b>Java-8.0:</b> had <b>Parallel Streams & CompletableFuture</b>
****[#a] <i><color #black><size:14><b>Java-18:</b> onwards <b>[[docs/3-programming-languages/Venkat-Subramaniam/Virtual-Threads.puml Virtual Threads]]</b> are under discussion\n*<i><color #black><size:14>Maybe after three years from now we learn from the problems with virtual threads & then try to solve it
***[#green] <i><color #white><size:14><b>[[docs/3-programming-languages/Venkat-Subramaniam/gif/synchronous-vs-asynchronous.adoc Parallel vs Asynchronous]] gif
***[#green] <i><color #white><size:22><b>[[docs/3-programming-languages/Venkat-Subramaniam/Spearheading-the-future-of-programming-2023.puml What does it mean to be "asynchronous"?]]
****[#yellow]:<i><color #black><size:14><b>Asynchronous is "non-blocking" "request/call"
* <i><color #black><size:14>**Non-blocking** means you don't want to block your "thread of execution" & "wait" for it to finish
* <i><color #black><size:14>**Benefit of Non-blocking** is your thread becomes available to do other things
* <i><color #black><size:14><b>"Tasks:"</b>  are always "blocking". It has to wait & finish the next job but your thread becomes "non-blocking";
****[#yellow] <i><color #black><size:14><b>What does the thread do?
****[#yellow] <i><color #black><size:14><b>"Paradigm Shift"; Learning a different paradigm
***[#green] <i><color #white><size:14><b>Starting a thread & blocking on it?
****[#yellow]:<i><color #black><size:14><b>How do we structure all of this to work on it?
* <i><color #black><size:14><b>Performance</b> reasons (less critical)
* <i><color #black><size:14><b>Interoperability</b> reasons (more critical)
* <i><color #black><size:14><b>Responsiveness</b> reasons (more critical);
****[#yellow] <i><color #black><size:14><b>Blocking is not a good option!
***[#green] <i><color #white><size:14><b>Starting a thread & passing a function to a call?
****[#yellow] <i><color #black><size:14><b>Threads are not working properly so lets create more threads. This is not a good logic!
***[#green] <i><color #white><size:14><b>Why not callbacks?
****[#yellow] <i><color #black><size:14><b>JavaScript, Callback hell!
**[#lightblue] <i><color #blac><size:22>[[docs/3-programming-languages/Venkat-Subramaniam/CompletableFuture.puml Completable Future]]
***[#green] <b><i><color #white><size:14>"Promises" of JavaScript
****[#yellow] <i><color #black><size:14>"Promises" in "JavaScript" are excatly same as "CompletableFuture in Java" but with different names
****[#yellow]:<i><color #black><size:14>"Promises" think of it as a <b>Data-structure.</b> It can be in <b>three different states:
* <i><color #black><size:14>"<b>Pending</b> (state) transient keeps changing
* <i><color #black><size:14>"<b>Resolved</b> (terminal state) when entered in this state it does not changes anymore
* <i><color #black><size:14>"<b>Rejected</b> (terminal state) when entered in this state it does not changes anymore;
****[#yellow] <i><color #black><size:14><b>Railway track pattern\n<img:images/img_11.png>\n*<i><color #black><size:14><b>Upper track is "Data Stream"\n*<i><color #black><size:14><b>Lower track is "Error Stream"
*****[#yellow] <i><color #black><size:14><b><img:images/img_12.png>
****[#yellow] <i><color #black><size:14><img:images/img_13.png>
**[#lightblue] <i><color #blac><size:22>[[docs/3-programming-languages/Venkat-Subramaniam/Continuation-and-Coroutines.puml Continuations & Coroutines]]
***[#green] <b><i><color #white><size:14>In Kotlin
***[#green] <b><i><color #white><size:14>Subroutines
***[#green] <b><i><color #white><size:14>Coroutines (functions or tasks)
***[#green] <b><i><color #white><size:14>Continuations
****[#yellow] <i><color #black><size:14>is a data structure that helps to restore the context of a call between calls to a coroutine
****[#yellow] <i><color #black><size:14>Continuations should be a data structure that you benefit from but should not have direct access to it
***[#green] <b><i><color #white><size:22>[[docs/3-programming-languages/Venkat-Subramaniam/Democratization-of-Technology.puml Democratization-of-Technology]]
**[#lightblue] <i><color #blac><size:22>[[docs/3-programming-languages/Venkat-Subramaniam/Virtual-Threads.puml Threads Vs Vritual Threads]]
***[#green] <b><i><color #white><size:14>In Java
***[#green] <b><i><color #white><size:14>Super lightweight
***[#green] <b><i><color #white><size:14>Managed by JVM
***[#green] <b><i><color #white><size:14>Mounting & unmounting
**[#lightblue] <i><color #blac><size:22>[[docs/3-programming-languages/Venkat-Subramaniam/CompletableFuture.puml Shift In Programming Model]]
***[#green] <b><i><color #white><size:14>From user Executor services
***[#green] <b><i><color #white><size:14>to using virtual threads
***[#green] <b><i><color #white><size:14>Executors, not pooled
****[#yellow] <i><color #black><size:14>Don't confuse <b>ExecutorService</b> with <b>pooling</b> they are not same
****[#yellow] <i><color #black><size:14>It makes no sense to <b>pool</b> <b>"virtual threads"</b>, please don't
****[#yellow]:<i><color #black><size:14>Somebody says I need pool of virtual threads. Ask Why?
*<i><color #black><size:14>**Virtual Threads** are like **qtips;** use them & throw around.;
***[#green] <b><i><color #white><size:14>Lock unlock data structure
****[#yellow] <i><color #black><size:14>Mounts & unmounts the <b>Thread
***[#green] <b><i><color #white><size:14>Synchronized keyword
****[#yellow] <i><color #black><size:14>Blocks the <b>Thread

**[#lightblue] <i><color #blac><size:22>[[docs/3-programming-languages/Venkat-Subramaniam/CompletableFuture.puml Usage patterns]]
***[#green] <b><i><color #white><size:14>Where does it make sense to use virtual threads?
****[#yellow] <i><color #black><size:14>When you 've mounting & unmouting <b>"blocking" operations
****[#yellow] <i><color #black><size:14><b>Benefit:</b> "Thread" is not <b>"blocked & waiting"</b> it unmounts & goes on
****[#yellow] <i><color #black><size:14><b>Benefit:</b> with few no. of "Threads" you can get same <b>"Throughput"</b> & more <b>scalability
***[#green] <b><i><color #white><size:14>Does & don'ts
****[#yellow] <i><color #black><size:14>Don't confuse <b>ExecutorService</b> with <b>pooling</b> they are not same
****[#yellow] <i><color #black><size:14>It makes no sense to <b>pool</b> <b>"virtual threads"</b>, please don't
****[#yellow]:<i><color #black><size:14>Somebody says I need pool of virtual threads. Ask Why?
*<i><color #black><size:14>**Virtual Threads** are like **qtips;** use them & throw around.;
****[#yellow] <i><color #black><size:14>Learn what <b>functions are mounting & unmounting</b> what are not. Otherwise you will not get the <b>"performance"</b> you are expecting
****[#yellow] <i><color #black><size:14>If you 've computationaly intensive operations/tasks then there is no use of giving it <b>"virtual threads"</b> because once you assign it \n<i><color #black><size:14>mounts & holds on to it & also the <b>overhead of mounting and unmounting

**[#lightblue] <i><color #blac><size:22>[[docs/3-programming-languages/Venkat-Subramaniam/CompletableFuture.puml Programming Models]]
***[#green] <b><i><color #white><size:14>Imperative ----to---> functional ----to----> imperative
****[#yellow] <i><color #black><size:14>In the past, the <b>structure</b> of <b>imperative style parallel code</b> was very\n<i><color #black><size:14>different from the <b>structure</b> of <b>imperative style sequential code.</b>
****[#yellow] <i><color #black><size:14>In Java 8, the <b>structure</b> of <b>functional style parallel code</b> is \n<i><color #black><size:14>same as the <b>structure</b> of <b>functional style sequential code.</b>
*****[#gold] <i><color #black><size:14>Thanks to <b>Streams!
****[#yellow] <i><color #black><size:14>In Java 8, the <b>structure</b> of <b>functional style asynchronous code</b> is \n<i><color #black><size:14>same as the <b>structure</b> of <b>functional style synchronous code.</b>
*****[#gold] <i><color #black><size:14>Thanks to <b>CompletableFuture!
****[#yellow] <i><color #black><size:14>Functional style is great, but working with <b>impurity & exceptions</b> is very difficult\n<i><color #black><size:14>& we loose the <b>elegance & the understanding</b> of it
****[#yellow] <i><color #black><size:14>In Java 21, the <b>structure</b> of <b>imperative style asynchronous code</b> is \n<i><color #black><size:14>same as the <b>structure</b> of <b>imperative style synchronous code.</b>
*****[#gold] <i><color #black><size:14>Thanks to <b>Virtual-Thread!
*****[#gold] <i><color #black><size:14>CompletableFuture has no <b>future! \n*<i><color #black><size:14>Because "exception handling" in FP is difficult\n*<i><color #black><size:14>Exception handling is imperative style programming idea!
*****[#gold] <i><color #black><size:14>CompletableFuture are great if you are using JDK 20 or less

@endmindmap
