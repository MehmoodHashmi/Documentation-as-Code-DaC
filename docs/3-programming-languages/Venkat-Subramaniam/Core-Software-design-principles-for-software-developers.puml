@startmindmap
title =<i><b><u>Core Software design principles for software developers\nDr.Venkat Subramaniam -  2015
* ==<i><b>[[docs/3-programming-languages/Venkat-Subramaniam/Towards-an-Evolutionary-Architecture.puml Towards an Evolutionary Architecture]]
** <i><b>[[https://www.youtube.com/watch?v=llGgO74uXMI&ab_channel=Devoxx Core Software design principles for software developers by Venkat Subramaniam]] video
*** <i><b>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_59.png "Learning this does not guarantee earning money" Robert C Martin]] image
!theme hacker

*[#darkblue] <i>Core Software design \n<i>principles for software developers
**[#lightblue] <i><color #black><size:14>Introduction
***[#green]:<i><color #white><size:14>**Writing code is easy. Writing good quality code is an entirely different story.** How can we measure quality of design? How do we know we're doing the
<i><color #white><size:14>right set of things that will leads us to a <b>better design?;

**[#lightblue] <i><color #black><size:14>What is a good design?
***[#green] <i><color #white><size:14><b>Usually my thinking is
****[#yellow] <i><color #black><size:14>The Design is good because <b>"I created it!"
****[#yellow] <i><color #black><size:14>We need better approach than that!
***[#green] <i><color #white><size:14><b>Good design
****[#yellow] <i><color #black><size:14>When **cost** of "changing the design" is <b>minimum
****[#yellow] <i><color #black><size:14>Change the design along the way
****[#yellow] <i><color #black><size:14>Almost impossible to get **design** right the first time (in one sitting)
****[#yellow] <i><color #black><size:14>Software is never **written,** it is always <b>rewritten.
*****[#gold] <i><color #black><size:14>Because any "software" that is **"relevant"** has to <b>change\n*<i><color #black><size:14>Otherwise, it means your **"client or business"** has become <b>bankrupt
**[#lightblue] <i><color #black><size:14>How to evaluate quality\n<i><color #black><size:14>of good design?
***[#green] <i><color #white><size:14><b>First step is
****[#yellow] <i><color #black><size:14>Let go of the <b>ego.
*****[#gold] <i><color #black><size:14>The Design is good because <b>"I created it!"
***[#green] <i><color #white><size:14><b>Second step is
****[#yellow] <i><color #black><size:14>Be <b>unemotional
*****[#gold] <i><color #black><size:14>Stop getting attached to the **solution,** and attach yourself to <b>solving the problem
****[#yellow] <i><color #black><size:14>Two Kinds of people that are dangerous to <b>work:\n*<b><i><color #black><size:14>Who can't follow instructions \n*<b><i><color #black><size:14>Who can only follow instructions
**[#lightblue] <i><color #black><size:14>How to create good design?
***[#green] <i><color #white><size:14><b>Take time to "review" design & code
****[#yellow] <i><color #black><size:14><b>Refactor:</b> others people code
****[#yellow] <i><color #black><size:14><b>Rewrite:</b> your own code
***[#green] <i><color #white><size:14><b>Two values of software
****[#yellow] <i><color #black><size:14><b>Structural value: </b>(is **architecture** & often ignored by the <b>developers)
****[#yellow] <i><color #black><size:14><b>Behavioral value: </b>(is **use cases** or feature development )
****[#a]:<i><color #black><size:14><b>The book Cathedral & bazaar in late 1990's said two values of software are:
<i><color #black><size:14><b>1- Use value
<i><color #black><size:14><b>2- Sale value
==<i><color #black><size:14><b>After the rise of [[docs/AI-ML-DL-Data-Science-and-BigData/machine-learning-ML/Modern-Machine-Learning.puml Modern Machine Learning]] ([[docs/AI-ML-DL-Data-Science-and-BigData/machine-learning-ML/3-deep-learning-DL/Deep-Learning.puml & Deep Learning]])==
*<i><color #black><size:14><b>Data [[docs/AI-ML-DL-Data-Science-and-BigData/big-data/big-data.puml (Big Data)]] has "value".;
**[#lightblue] <i><color #black><size:14>Keep it simple
***[#green] <i><color #white><size:14><b>KISS principle
****[#yellow] <i><color #black><size:14><b>Keep it "simple" and stupid
****[#yellow] <i><color #black><size:14><b>Most of us don't know what is <b>"simple"
***[#green] <i><color #white><size:14><b>Simple
****[#yellow] <i><color #black><size:14><b>Keeps you "focused"
****[#yellow] <i><color #black><size:14><b>Solves only "real problems" we know about
****[#yellow] <i><color #black><size:14><b>Fails less (is resilient & robust)
****[#yellow] <i><color #black><size:14><b>Easier to "understand"
****[#yellow] <i><color #black><size:14>Has few "moving parts" in it
****[#yellow] <i><color #black><size:14><b>Efficiency</b> is attained not by doing <b>tasks faster,\n<i><color #black><size:14>but by avoiding those tasks that <b>should not be done in the first place.
**[#lightblue] <i><color #black><size:24>[[docs/3-programming-languages/Venkat-Subramaniam/images/complexity-knowledge-and-Modularity.jpg Complexity]]\n<img:images/img_32.png>
***[#green] <i><color #white><size:14><b>Inherent or Essential
****[#yellow] <i><color #black><size:14>is from the **problem domain,** you can't minimize it. When dealing with the **problem;** there are **"complexities"** \n<i><color #black><size:14>of the **problem** that you 've to deal with. And this is the "nature of the application" and **nature** of the <b>domain.
****[#yellow] <i><color #black><size:14>Fortunately, on daily basis we 've to deal more with the <b>accidental "complexities"</b> than <b>inherent "complexities"
***[#green] <i><color #white><size:14><b>Accidental
****[#yellow]:<i><color #black><size:14>Often, comes from the **solution** we use to solve a **particular problem.** The **solution** we are using brings
<i><color #black><size:14>certain **complexities** into the <b>table.
*<i><color #black><size:14>Now, to solve this **introduced "complexities"** we bring <b>other solutions.
*<i><color #black><size:14>**Other solutions,** bring more **"complexities"** & this goes on & on.;
****[#gold] <i><color #black><size:14>The **problem** did not require a **specific solution,** its the **solution we choose** to solve the <b>problem!
****[#yellow] <i><color #black><size:14><b>E.g. Concurrency
****[#yellow] <i><color #black><size:14><b>E.g. Streams </b>(less accidental complexity)
****[#yellow] <i><color #black><size:14>Simple is not necessarily Familiar
*****[#gold] <i><color #black><size:14>e.g. <b>For loop
***[#green] <i><color #white><size:14><b>Good Design
****[#gold] <i><color #black><size:14>A **good design** is the one that **"hides" or "encapsulates"** the <b>inherent complexity\n<i><color #black><size:14>and <b>"eliminates" the <b>accidental complexity
****[#gold] <i><color #black><size:14><b>Follow YAGNI Principle
**[#lightblue] <i><color #black><size:14>Think YAGNI
***[#green] <i><color #white><size:14><b>You are not goona need it yet!
***[#green] <i><color #white><size:14><b>When should I implement something?
****[#gold] <i><color #black><size:14><b>How much do you know?
****[#gold] <i><color #black><size:14><b>Cost of implementing?
****[#yellow] <i><color #black><size:14>Like **"Rewrite"** java app in go-lang or C# or python, this is difficult, time consuming & hard to <b>reverse.
****[#yellow] <i><color #black><size:14>The more you are couple to a decision the harder it is to reverse, introduce indirection to increases <b>reversibility.
****[#yellow] <i><color #black><size:14>Things which are irreversible (expensive to change) **postponed** them till the end of the <b>implementation.\n*<b><i><color #black><size:14>Why don't we postpone?\n**<b><i><color #green><size:14>Because we are afraid!\n*<b><i><color #black><size:14>If you want ot "postpone" we need to 've good "automated testing". (TDD)
****[#yellow] <i><color #black><size:14>Database decisions, libraries and frameworks decisions etc.
****[#darkorange] <i><color #black><size:16>**[[docs/1-Requirement-Engineering/MVP-PoC-and-case-study/Prototyping.puml Prototyping]]** is helpful. \n*<i><color #black><size:14>**[[docs/3-programming-languages/Venkat-Subramaniam/Unix-Philosophy.puml 15- Rule of optimization]]** unix philosophy
****[#yellow] <i><color #black><size:14>**YAGNI principle** is not goona help you, if you 've very <b>poor (slow) feedback loop
**[#lightblue] <i><color #black><size:14>Cohesion
***[#green] <i><color #white><size:14><b>Where a piece of code is narrow, "focused"\n<i><color #white><size:14><b>& does one thing & does one thing well!
****[#yellow] <i><color #black><size:14>We want software to change, but not too <b>(expensive to change)
****[#yellow] <i><color #black><size:14>If a "code" is **"cohesive",** it has to <b>change less "frequently"
***[#green] <i><color #white><size:14><b>Like things stay together, and unlike things stay apart
****[#yellow] <i><color #black><size:14>**"Code that deals"** with **database** is different than **"code that deals"** with <b>XML processing
****[#yellow] <i><color #black><size:14>**"Code that deals"** with **database** is different than **"code that deals"** with <b>UI
**[#lightblue] <i><color #black><size:22>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_51.png Coupling]]
***[#green] <i><color #white><size:14><b>is what you depend on
****[#yellow] <i><color #black><size:14>Worst form of coupling is <b>inheritance
****[#yellow] <i><color #black><size:14>Try to see if you can remove coupling
****[#yellow] <i><color #black><size:14>"knock out before you mock out"
****[#yellow] <i><color #black><size:14>Can't remove all the <b>dependencies
*****[#gold] <i><color #black><size:14>**"System"** will become so **"stable"** that it won't even <b>run!\n*<i><color #black><size:14>E.g. if all **classes** are **abstract,** then none of them can be <b>instantiated.

***[#green] <b><i><color #white><size:14>Dealing with Coupling
****[#yellow] <i><color #black><size:14>Get rid of it
****[#yellow] <i><color #black><size:14>Extremely **loose coupling requires** very **few rules,** but they need to be <b>enforced strictly.
****[#yellow]:<i><color #black><size:14>Make it "loose" instead of <b>tight coupling
==<b><i><color #black><size:14>Tight coupling?==
*<i><color #black><size:14>Depending on a <b>class</b> is <b>tight coupling
*<i><color #black><size:14>Depending on an<b> interface</b> is <b>"loose" coupling;
***[#green] <i><color #white><b><size:14>High Cohesion & Coupling
****[#yellow] <i><color #black><size:14><b>"Good design" has "high cohesion" & "low Coupling"
***[#green] <i><color #white><b><size:14><img:images/img_42.png{scale=0.935}>\n<i><color #white><b><size:18>The spectrum of "contract types" from "strict to lose"\n<img:images/img_46.png>
****[#yellow]:<i><color #black><size:14>**How do yo decouple one module from another?** That depends on the **level of decoupling you need.** Sometimes simply extracting code
<i><color #black><size:14>into a separate function is enough. More often, it's better to move all the **related code** into a **separate class** & even a separate **source file.**
<i><color #black><size:14>And in extreme cases, you want to put those classes behind <b>polymorphic interfaces.;

****[#yellow] <i><color #black><b><size:14>In general:
*****[#darkorange]:<i><color #black><size:14>**Logical design** (classes & packages) impacts <color #white><b> [[docs/3-programming-languages/Venkat-Subramaniam/Towards-an-Evolutionary-Architecture.puml "extensibility"]]
====
*<i><color #black><size:14>**Methods:** one function calling another "function". <b>requires recompilation &  static linking
*<i><color #black><size:14>**Modules:** one function calling another "function". <b>requires no recompilation & supports dynamic linking;
*****[#darkorange]:<i><color #black><size:14>**Physical design** (.jar) impacts <color #white><b>"re-usability & usability"
====
*<i><color #black><size:14>**Components:** "communication" with each other using "socket, shared memory, IPC, mail boxes or message queues"
<i><color #black><size:14> **"components"** can be <b>statically or dynamically linked. e.g. .Jar, DLL, etc.
**<i><color #black><size:14>**Components "Classification":**
<i><color #green><size:14><b>\t1- Compile time,
<i><color #green><size:14><b>\t2- Some exist only at link time,
<i><color #green><size:14><b>\t3- Some exist only at runtime; &
<i><color #green><size:14><b>\t4- Some exist at more than one time.
*<i><color #black><size:14>**.War:** many ".Jar" inside a <b>.war file;
*****[#darkorange] *<i><color #black><size:14>**Modules:** are a **new** way of "grouping" <b>codes & data.\n*<i><color #black><size:14>**Modularity:** is not an **OOP**  "concept" it's **decoupled** from <b>OOP.
***[#green] <i><color #white><b><size:14>Boundary Anatomy (structure, framework, composition)
****[#darkorange] <i><color #black><size:14>The **<u>"architecture"</u>** of a **<u>"System"</u>** is defined by a <u>**set of "software components"**</u> \n<i><color #black><size:14>& the **boundaries** that <u><b>separate</u> them. from book "Clean Architecture"
*****[#yellow] <i><color #black><size:14>**1-** Crossing Boundaries. How? use <b>DIP\n<i><color #black><size:14>**2-** Which **data** crosses boundaries? simple <b>DTO's
***[#green] <i><color #white><size:14><b>Many Ways to decouple \n<i><b><color:pink><size:18>"use cases & layers"
****[#gold] <i><color #black><size:14><b>Source level
*****[#darkorange] <i><color #black><size:14><b>"TDD" can help here
****[#gold] <i><color #black><size:14><b>Deployment level
*****[#darkorange] <i><color #black><size:14><b>is modular monolith
****[#gold] <i><color #black><size:14><b>Service level
****[#a]:<i><color #black><size:14>It's not difficult to imagine that a **"System"** that runs comfortably on **"one server"** right now **"might grow"** to the point where some of its **"components"** ought ('ve to) to run
<i><color #black><size:14>on **separate server**. While the **"System"** runs on single server, the **"source-level" decoupling** might be sufficient. Later, however, it might require decoupling to
<i><color #black><size:14>**deployable units, or even "services"**. <b>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_54.jpg click me]] & [[a Conway's law]] click me;
***[#green] <i><color #white><b><size:14>Software component \n<i><color #white><b><size:14>boundaries means:
****[#darkorange] <i><color #black><size:14>**1- Boundary** crossing at <b>runtime:\n<i><color #black><size:14> <b>(source code dependencies)
*****[#yellow]:*<i><color #black><size:14>**Communication** through <b>function calling.
**<i><color #green><size:14><b>f.(o) is same as o.f()
*<i><color #black><size:14>**Communication** is <b>fast & inexpensive
*<i><color #black><size:14>requires <b>recompilation & static linking
*<i><color #black><size:14>"components" are delivered as <b>source code
*<i><color #black><size:14>function calling is on "same" <b>processor & address space;
******[#yellow] <i><color #black><size:14><img:images/img_48.png> <img:images/img_53.jpg{scale=0.89}> <img:images/img_49.png{scale=0.72}>
****[#darkorange] <i><color #black><size:14>**2- Deployment**\n<i><color #black><size:14><b>component boundary
*****[#yellow]:*<i><color #black><size:14>**Communication** through <b>function calling
*<i><color #black><size:14>**Communication** is <b>fast & inexpensive
*<i><color #green><size:14>requires <b>no recompilation & supports dynamic linking
**<i><color #green><size:14>**changes** to the **"source code"** in one **module/class** don't
<i><color #green><size:14>     force others to be <b>rebuilt & redeployed.
*<i><color #green><size:14>"components" are delivered as <b>.Jar, DLL, .class files in java
*<i><color #black><size:14>function calling is on "same" <b>processor & address space;
******[#yellow] <i><color #black><size:14><img:images/img_47.png>    <img:images/img_50.png{scale=0.9}>
*******[#a]:<i><color #black><size:14>**[[docs/3-programming-languages/Venkat-Subramaniam/images/complexity-knowledge-and-Modularity.jpg Modularity]]** decreases the **model-code gap** & increases <b>"abstraction"
<img:images/img_53.png{scale=0.8}>
<i><color #black><size:14>Still **cost is higher** because you 've to know about <b>[[docs/3-programming-languages/Venkat-Subramaniam/images/complexity-knowledge-and-Modularity.jpg modularity]] click me;
****[#darkorange] <i><color #black><size:14>**3- Thread boundary**
*****[#yellow] <i><color #black><size:14>are not boundaries both **source code dependencies & deployment component boundary** can make use of <b>threads.
****[#darkorange] <i><color #black><size:14>**4- Local Process boundary**
*****[#a]:*<b><i><color #black><size:14>[[docs/books/1-books-backlog/operating-system/operating-system.puml local processes "communicate" with each other using "socket, shared memory, IPC, mail boxes or message queues"]]
*<i><color #black><size:14>**Communication** across **local process boundaries** involve:
**<i><color #black><size:14><b>[[docs/books/1-books-backlog/operating-system/operating-system.puml operating system calls, data marshalling & decoding, & inter-process context switches which are moderately expensive]]
*<i><color #black><size:14>**Communication** is <b>fast & expensive
*<i><color #yellow><size:14>local processes can be <b>statically or dynamically linked
*<i><color #yellow><size:14>**"Components"** are delivered in <b>binary or .Jar, DLL</b> or some equivalent form.
*<i><color #yellow><size:14>Processes execute on "same" <b>processor or multi-core but "separate address space". [[docs/books/1-books-backlog/operating-system/operating-system.puml click me]];
****[#darkorange] <i><color #black><size:14>**5- Services Boundary:**
*****[#yellow]:*<i><color #black><size:14>Service is a <b>process
*<i><color #black><size:14>"Service" don't depend upon <b>physical location
*<i><color #black><size:14>Two communicating "services" may, or may not, operate in the "same" <b><u>physical processor or multi-core machine.
*<i><color #black><size:14>The **"services"** assume that all **"communication"** take place <b>over the network.
*<i><color #black><size:14>**Communication** across **"service boundaries"** are very **slow** compared to <b>function calls;
**[#lightblue] <i><color #black><size:14>Keep it DRY!
***[#green] <i><color #white><b><size:14>Don't Repeat yourself
****[#yellow]:<i><color #black><size:14>Don't duplicate <b>code
====
*<i><color #black><size:14>Every "piece of knowledge" in a "System" should 've <b><u>single unambiguous authoritative representation
*<i><color #black><size:14>It "reduces" the "cost" of "development"
*<i><color #black><size:14>The future you will thank you!
*<i><color #black><size:14><b>Do code refactor!
**<i><color #black><size:14><b>Some tools:
*** <i><color #black><size:14><b>CPD (Copy paste detector)
*** <i><color #black><size:14><b>Simian (means monkey)</b> Detects code if you copy & pasted code at several places;

****[#yellow] <i><color #black><size:14>Don't duplicate <b>effort
*****[#gold] <i><color #black><size:14><b>A cascade change
**[#lightblue] <i><color #black><size:14>Focus on "Single Responsibility Principle"\n*<i><b>[[docs/3-programming-languages/Venkat-Subramaniam/Unix-Philosophy.puml 2- Rule of Clarity]]
***[#green] <i><color #white><size:14><b>Long Methods
****[#yellow]:<i><color #black><size:14><b>//Comment...

<i><color #black><size:14>Code...

<i><color #black><size:14><b>//Comment...

<i><color #black><size:14>Code...

<i><color #black><size:14><b>//Comment...

<i><color #black><size:14>Code...

<i><color #black><size:14><b>//Comment...

<i><color #black><size:14>Code...;
*****[#gold]:<i><color #black><size:14><b>Long Methods are bad:</b>
*<i><color #black><size:14>Hard to test <b>(TDD)
*<i><color #black><size:14>Hard to read
*<i><color #black><size:14>Hard to remember
*<i><color #black><size:14>Obscured business rules
*<i><color #black><size:14>Hard to <b>reuse
*<i><color #black><size:14>Leads to duplication
*<i><color #black><size:14>many reasons to change
*<i><color #black><size:14>Can't be optimized by anything
*<i><color #black><size:14>Lot of variables...
*<i><color #black><size:14>Not developer friendly
*<i><color #black><size:14><b>Mixed levels
*<i><color #black><size:14>Obsolete comments
*<i><color #black><size:14>Hard to debug <b>(victim);
******[#yellow] <i><color #black><size:14><b>Opposite of:\n*<i><color #black><size:14><b>High Cohesion\n*<i><color #black><size:14><b>Low Coupling
****[#yellow]:<i><color #black><size:14><b>How "long" is a "long method"?
*<i><color #black><size:14><b>The answer is <b>"SLAP"</b> (Single Level of Abstraction)
*<i><color #black><size:14>Don't comment "bad code" instead <b>refactor bad code
*<i><color #black><size:14>Don't comment **"What",** instead <b>comment "Why"
*<i><color #black><size:14>A good code is like a <b>joke
**<i><color #black><size:14>refactor it if it doesnt work;
***[#green] <i><color #white><size:14><b>SLAP
***[#green] <i><color #white><size:14><b>Compose Method Pattern
****[#gold] <i><color #black><size:14><b>Self documenting code
**[#lightblue] <i><color #black><size:14>Don't violate the \n<i><color #black><size:14>Open-Closed Principle (OCP)
***[#green] <i><color #white><size:14><b>"Software module" should be "open" for\n<i><color #white><size:14><b>"extension" but "closed" for "modification"
****[#gold] <i><color #black><size:14><b>Abstraction
****[#gold] <i><color #black><size:14><b>Polymorphism
***[#green] <i><color #white><size:14><b>Two options: to make an "enhancement":
****[#gold] <i><color #black><size:14><b>1- Change an existing code <size:20><&circle-x>
****[#gold] <i><color #black><size:14><b>2- Add a small new "module" of code <&check>
***[#green] <i><color #white><size:14><b>A class/code can't be "infinitely extensible,"
****[#gold] <i><color #black><size:14>It is only extensible for <b>"what you design for"!
****[#gold] <i><color #black><size:14>Who can make extensible?\n*<i><color #black><size:14>We need to know <b>software & domain knowledge
***[#green] <i><color #white><b><size:14>Three Kinds of people in we work with:
****[#yellow] *<i><color #black><size:14><b>People with domain knowledge but no clue of Software design\n*<i><color #black><size:14>Too many in an organization
****[#yellow] *<i><color #black><size:14><b>People with no clue of domain knowledge but with knowledge the Software design\n*<i><color #black><size:14>Too many in an organization
****[#gold] *<i><color #black><size:18><b>People with domain knowledge & also knowledge of the Software design\n*<i><color #black><size:14>Very few in an organization
**[#lightblue] <i><color #black><size:14>Keep in mind \n<i><color #black><size:14>Liskov's Substitution Principle
***[#green] <i><color #white><b><size:14>Inheritance overused
****[#gold] *<i><color #black><size:14>Bad thing!
***[#green] <i><color #white><b><size:14>Inheritance should be used \n<i><color #white><b><size:14>only for substitutability
****[#gold] *<i><color #black><size:14>If **an object of B** should be "used" anywhere **an object of of A** is used then use <b>inheritance.
****[#gold] *<i><color #black><size:14>If **an object of B** should "use" **an object of A**, then use <b>"composition or delegation".
****[#yellow] *<i><color #black><size:14>**Inheritance** demands more from a "developer" than **composition or delegation** does.
****[#yellow]:*<i><color #black><size:14>**Services** of the **derived class** should "require" no more & "promise" no less than the corresponding
<i><color #black><size:14>**"services"** of the <b>base class.
==<i><color #black><b><size:14>Why?==
*<i><color #black><size:14>**Reason:** The "user" of a **base class** should be able to "use" an **instance** of a <b>derived class</b> without
<i><color #black><size:14>knowing the difference.
==<i><color #black><b><size:14>How?==
*<i><color #black><size:14>You & I 've to make sure that we protect it at the <b>"code level."</b> Otherwise design begins to fall apart.
<i><color #black><size:14>And we don't know why it's falling apart.
*<i><color #black><size:14>Violation of the <b>"Liskov's substitution principle"</b> may result in violation of the <b>Open-Closed Principle (OCP);
***[#green] <i><color #white><b><size:14>Good
****[#yellow] <i><color #black><size:14>Public vs. protected in base vs. derived class
****[#yellow] <i><color #black><size:14>Derived functions can't throw any new checked exceptions no thrown by the base class (Unless the new exception extends the old one...)
****[#yellow] <i><color #black><size:14>Collection of derived class does not extend from collection of base class.
****[#yellow]:<i><color #black><size:14>Use **Composition or delegation** instead of **inheritance** unless:
*<i><color #black><size:14>You want <b>substitutability;
***[#green] <i><color #white><b><size:14>Bad
****[#gold]:<b><i><color #black><size:14>Should I violate LSP or should I violate DRY & OCP?
<i><color #black><size:14>If I violate LSP then the user of the class probably is gonna violate <b>OCP.</b> I would rather violate it, then violate myself & force to violate as well
<i><color #black><size:14>the sin is in me I don't want you the part of sin as a user of my class.
==<i><color #black><size:14><b><u>What if I don't had to violate it at all?==;
**[#lightblue] <i><color #black><size:14>Decouple using the \n<i><color #black><size:14>Dependency Inversion Principle
***[#yellow] <i><color #black><size:14>"Every single line of **code"** that **"uses"** the "**new** keyword" violates <b>"DIP".
***[#green] <i><color #white><b><size:14>A "class" should not "depend" on "another class", they both should\n<i><color #white><b><size:14>'ve to "depend" on an "abstraction" (interface<color:lime>/abstract) class.
****[#yellow] <i><color #black><size:14>lowers the coupling
****[#yellow] <i><color #black><b><size:14>Use with caution
****[#a] <i><color #black><size:14>**Interface/Abstract class** has its own <b>[[docs/3-programming-languages/Venkat-Subramaniam/images/img_57.png drawback]]
****[#yellow] <i><color #black><size:14>Use more **lambda expressions** as "implementors" of \n<i><color #black><size:14>the **interface/abstract classes** rather than using the \n<i><color #black><size:14>"anonymous inner classes" or "regular classes".
**[#lightblue] <i><color #black><size:14>Keep "interfaces Cohesive" with \n<i><color #black><size:14>"Interface Segregation Principle"
***[#green] <i><color #white><b><size:14>"Code" should not depend on "methods" it doesn't "use".
****[#yellow] <i><color #black><size:14>The **goal** of the **ISP** is to reduce the side-effects of using large interfaces by breaking them into smaller, more specific interfaces.
****[#yellow] <i><color #black><size:14>Really is **"cohesion", "Single Responsibility Principle" (SRP)** \n<i><color #black><size:14>but at the <b>interface-level.
**[#lightblue] <i><color #black><size:14>When to apply these principles?
***[#green] <i><color #white><b><size:18>2-Phases \n<i><color #white><b><size:18>of Design:
****[#yellow]:<i><color #black><size:14>**Strategic Design:** very high-level design.
*<i><color #black><size:14>Gives "direction & ideas" <b>to go to.
*<i><color #black><size:14>**SOLID, YAGNI, DRY, & other principles** are used **little bit** during <b>strategic design.;
****[#yellow]:<i><color #black><size:14>**Tactical Design:** often low-level design,
*<i><color #black><size:14>Paves the way to refine those "directions & ideas" into realities of the project
*<i><color #black><size:14>**SOLID, YAGNI, DRY, & other principles** are used **a lot** during <b>tactical design.;
***[#green] <i><color #white><b><size:18>How to apply these principles?
****[#gold] <i><color #black><size:14>Machine Learning <b>"Model" "Testing" is different than <b>(TDD)</b> that is:
*****[#gold] <i><color #black><size:11><b>"Testing" "Model's"
******[#darkorange] <i><color #black><size:14>**1-** Prediction\n<i><color #black><size:14>**2-** Pattern recognition\n<i><color #black><size:14>**3-** Optimization & decision making
****[#yellow] <i><color #black><size:14>**1-** Use as a way to discuss **"among developers",** sit down with "developers" & say \n<i><color #black><size:14>hey if we do this we may **violate LSP or OCP or DIP.** So apply <b>YAGNI & postpone
****[#yellow]:<i><color #black><size:14>**2-** Use during <b>(TDD)
==<i><color #black><size:14><b>How?==
*<i><color #black><size:14>When start writing **Test cases**, ask "yourself" the following <b>questions:
**<i><color #black><size:14>What does this **"test"** do?
**<i><color #black><size:14>How does this "feels" to "use" this <b>object?
**<i><color #black><size:14>What are the <b>consequences?
***<i><color #black><size:14>Am I increasing coupling when I'm using this particular object?
***<i><color #black><size:14>What is <b>"cohesion"?
****<i><color #black><size:14>What is the **"responsibility"** of the "class" I'm <b>designing?
****<i><color #black><size:14>If I **"use"** this particular **"code"**, am I going to **violate (OCP)** here?
****<i><color #black><size:14>Should I really "use" **DIP** to gain access & **test** this <b>code?
<img:images/img_44.png{scale=0.81}>;
****[#gold] <i><color #black><size:14>**3-** Micheal Feathers: said In "OOP" we **"encapsulate"** the **"moving parts"**, in "FP" we **"eliminate"** the <b>"moving parts"
**[#lightblue] <i><color #black><size:14>Summary [[docs/3-programming-languages/Venkat-Subramaniam/images/img_55.png click me]]\n<img:images/img_55.png{scale=.16}>

@endmindmap
